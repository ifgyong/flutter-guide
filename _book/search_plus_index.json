{"./":{"url":"./","title":"简介","keywords":"","body":"Introduction Copyright © ifgyong 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-24 15:11:27 "},"books/3.3textandstyle.html":{"url":"books/3.3textandstyle.html","title":"文本和样式","keywords":"","body":"文本和样式 3.1 Text and TextStyle text用于显示简单的文字和样式，下面看下简单的例子 Text('text HelloWord', textAlign: TextAlign.left,) Text( '加了style的文本', style: TextStyle( color: Colors.red, fontSize: 30, height: 1.4, background: new Paint()..color = Colors.black12, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy), ) 效果如下： 一个是简单的文本显示，属性 textAlign:TextAlign.left 好像没起作用，原因是文本没超过一行，没效果。 底部波纹代码如下： decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy 这三行的样式是在底部添加了波纹线，SDK一共给了4中线的样式， enum TextDecorationStyle { /// Draw a solid line solid, /// Draw two lines double, /// Draw a dotted line dotted, /// Draw a dashed line dashed, /// Draw a sinusoidal line wavy } 效果如下： 喜欢哪一个随意挑选哦。 当文本超过一行的话可以截断或者换行 用到了属性TextOverflow Text( 'TextOverflow.visible' * 10, textAlign: TextAlign.left, maxLines: 1, overflow: TextOverflow.visible, ) 官方提供了四种方式，在设置maxLines=2效果如下 默认maxLines是无限的，自动换行的。如果设置固定行数，则文本最多不超过该行数，超过该行数则被截断，截断方式如上图所示。系统还提供了文字间隔wordSpacing和字符间隔letterSpacing，字体放大倍数textScaleFactor,如果不设置 ，会 MediaQueryData.textScaleFactor获取，默认是1.0。 3.2. TextSpan 首先看一个简单例子： TextSpan( text: 'Jok Ma,hello!', style: TextStyle( fontSize: 20, ), children: [ TextSpan( text: 'Bo', style: TextStyle( fontSize: 20, color: Colors.blue, backgroundColor: Colors.black12)), TextSpan( text: 'b,hello!', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent)), TextSpan( text: 'two line', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.double)), TextSpan( text: '\\n点击打开我 🖱http://www.fgyong.cn', style: TextStyle(fontSize: 20, height: 2), recognizer: new TapGestureRecognizer()..onTap = () { _openUrl('http://www.fgyong.cn'); }, ), ]), ), //是否打开url void _openUrl(String url) async { if (await canLaunch(url)) { await launch(url); } else { throw 'could not launch $url'; } } 效果如下： 这里使用了TextSpan组件，和Text类似的都有style，这一点完全一致，不同的是TextSpan可以添加children,这是一个数组，可以连续添加很多TextSpan,每个都可以单独设置样式，比如一个手机号，一个网址，。。可以通过recognizer: new TapGestureRecognizer()..onTap = _openUrl来实现点击文本跳转_openUrl函数，这给文本带来了更多的可能性。 height属性是计算方式是fontSize * height，默认是1.0，设置字体大小还有一个属性是textScaleFactor，这个是计算方式是fontSize * textScaleFactor,默认是1.0. fontSize字体具体的大小 height 行高 textScaleFactor，本质是fontSize * textScaleFactor,默认是1.0 * fontSize 3.3 DefaultTextStyle 可以被继承的TextStyle,当一个子树基本样式类似，可以使用DefaultTextStyle DefaultTextStyle( //1.设置文本默认样式 style: TextStyle( color: Colors.blue, fontSize: 30.0, ), textAlign: TextAlign.start, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(\"Jack Ma\"), Text(\"I am Ok\"), Text( \"I am Jack\", style: TextStyle( inherit: false, //2.不继承默认样式 color: Colors.grey), ), ], ), ) 效果如下： 这里边默认样式是字体大小30(逻辑像素),然后通过DefaultTextStyle设置子树的样式，这样子所有子树中的样式都遵从该样式，可以通过inherit: false显示指定不继承该样式。 3.3.4 字体 当开发人员想使用自定义(非默认)字体,可以去Google下载，则可以通过pubspec.yml中声明他，然后将字体移动到目录下fonts下： 然后在pubspec.yml的声明如下： fonts: - family: Merriweather fonts: - asset: fonts/Merriweather-Black.ttf - asset: fonts/Merriweather-Light.ttf weight: 700 这样子就可以在textStyle中使用了 TextStyle(fontFamily: 'Merriweather',) 或者在主题中直接声明默认的字体 ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, fontFamily: 'Merriweather') 更多字体设置见官网 如果想省事可以使用google_fonts. Copyright © ifgyong 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 13:25:34 "},"books/3.4button.html":{"url":"books/3.4button.html","title":"按钮","keywords":"","body":"3.4 按钮 3.4.1 Material组件库的按钮 Material 组件库中提供了多种按钮组件如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton组件的包装定制，所以他们大多数属性都和RawMaterialButton一样。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现波纹的动画）。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 FlatButton FlatButton是一个扁平按钮，在默认背景透明无阴影，按下后有深色背景，如图： 使用起来很简单： FlatButton( child: Text('nomal'), onPressed: () {},), RaisedButton RaisedButton是漂浮按钮，默认带有背景和阴影，活跃状态按钮背景变大，如图所示 IconButton IconButton默认是icon作为widget，背景透明，按压状态下，波纹状，背景变大。如图所示 FloatingActionButton FloatingActionButton即是悬浮按钮，默认背景是主题色，按压也会有波纹。右边是按压，左边是正常状态。 使用例子： FloatingActionButton(child: Icon(Icons.add), onPressed: () {}, ) BackButton CloseButton 官方封装好的返回和关闭按钮,如图： 使用例子: BackButton(onPressed: () {},), CloseButton(onPressed: () {},), OutlineButton OutlineButton带边框的按钮，默认有灰色边框，按压下边框高亮，可以同时兼备icon和label,如图： 使用也很简单： OutlineButton( child: Text('OutlineButton'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('label'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('active'), onPressed: () {}, ) 自定义按钮外观 外观可以通过属性来定义，不同按钮基本一样，我们以IconButton为例子，介绍一下常用属性，详细的可以查看官方文档。 textColor : 文本和icon的颜色 disabledBorderColor: 不点击状态下的边框颜色 highlightedBorderColor： 点击状态下边框颜色 splashColor:波纹颜色 borderSide：边框宽度和颜色 示例： 代码如下： OutlineButton.icon( onPressed: () {}, icon: Icon(Icons.add), label: Text('diy style'), color: Colors.black12, textColor: Colors.blue, disabledBorderColor: Colors.black, highlightedBorderColor: Colors.greenAccent, splashColor: Colors.red ) 如何自己实现一个Button,在后续章节中会再次详细讲到，在此不过多累述。 Copyright © ifgyong 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 16:01:46 "},"books/3.5img.html":{"url":"books/3.5img.html","title":"图片和Icon","keywords":"","body":"3.5 图片及Icon 3.5.1 图片 Flutter中，我们可以通过image加载并显示图片，数据源可以是asset、file、内存、网络。 Image imageWidget有一个必选的参数，对应了一个ImageProvider,下边我们来演示一下image的使用。 从assets加载 首先将文件复制到工程指定文件夹内，我们移动至img文件夹下， 然后在pubpspec.yaml内声明 assets: - img/1.jpeg 然后运行flutter pub get,(或者 android studio 中编辑 pubpspec.yaml点击右上角pub get按钮)。 然后代码中可以使用了，实例: Image.asset('img/1.jpeg') 效果如图所示： 从网络加载 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, ) 或者使用快捷的构造函数Image.network用于从网络加载、显示图片 Image.network( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\", width: 120, ), 参数 Image在显示图片是定义了一系列参数，通过定义一系列参数达到改变图片外观、大小、混合效果等，我们看下Image的主要参数： const Image({ ... this.width, //图片的宽 this.height, //图片高度 this.color, //图片的混合色值 this.colorBlendMode, //混合模式 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ... }) width、height ：用户设置图片大小，当不指定大小，图片则在富容器内进行占满，当设置width或height时，另外一个会按照比例缩放，但可以通过fit来指定缩放规则。 fit:指定图片在容器内的缩放规则。有如下几个值 fill:会拉伸铺满，图片会变形 cover: 按照图片的长宽放大后填满容器，不会变形。 fitWidth: 图片会随着缩放到显示的宽度，在保证不变形的条件下进行适应宽度,超出部分会裁剪。 fitHeight:图片高度会按照等比例缩放到适应高度，超出部分会裁剪。 none: 无适应规则，会显示当前容器的大小，如果图片过大，则只会显示中间部分。 看图，简单明了： color指定混合颜色，colorBlendMode指定混合模式。 例子： Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, ) 效果： repeat是当图片不够容器大小可以设置沿着X或者Y进行重复铺。 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, height: 200, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, repeat: ImageRepeat.repeat, ) 效果： Image 从网络下载动画 Image从网络下载会与短暂的 空白时间，这是我们不想看到的，我们可以在加载的时候显示菊花转。 Image( image: NetworkImage( \"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2053400745,529716701&fm=26&gp=0.jpg\"), width: 100.0, height: 200, loadingBuilder: ( BuildContext context, Widget child, ImageChunkEvent loadingProgress, ) { if (loadingProgress == null) { return child; } return CircularProgressIndicator(); }, ) 效果如图所示： 3.5.2 Icon flutter中可以使用iconFont，就是将图标做成文件，通过指定字符加载不同icon. 字体文件中，每一个字符都对应一个位码，不同字体就是字形不同，即字符对应的字形不同，最终渲染的不同的图标。 Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下 uses-material-design: true Material Design所有图标可以在其官网查看. 例子： Text('\\uE915 \\uE002 \\uE900', style: TextStyle( fontFamily: \"MaterialIcons\", fontSize: 24.0, color: Colors.green)) 效果： 对着code 找图标明显不是太人性化，那么可以使用cupertino_icons Icon( Icons.clear, color: Colors.red, ), Icon( Icons.add, color: Colors.greenAccent, ), Icon( Icons.collections, color: Colors.blue, ), Icon( Icons.extension, color: Colors.orange, ) 使用自定义字体图标 我们也可以使用自定义字体图标。iconfont.cn上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在Flutter中，我们使用ttf格式即可。 假设我们项目中需要使用一个书籍图标和微信图标，我们打包下载后导入： 导入字体图标文件；这一步和导入字体文件相同，假设我们的字体图标文件保存在项目根目录下，路径为\"fonts/iconfont.ttf\"： fonts: - family: myIcon #指定一个字体名 fonts: - asset: fonts/iconfont.ttf 为了使用方便，我们定义一个MyIcons类，功能和Icons类一样：将字体文件中的所有图标都定义成静态变量： class MyIcons{ // book 图标 static const IconData book = const IconData( 0xe614, fontFamily: 'myIcon', matchTextDirection: true ); // 微信图标 static const IconData wechat = const IconData( 0xec7d, fontFamily: 'myIcon', matchTextDirection: true ); } 使用 Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(MyIcons.book,color: Colors.purple,), Icon(MyIcons.wechat,color: Colors.green,), ], ) 运行后效果如图3-22所示： Copyright © ifgyong 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 16:02:48 "},"books/3.6sw.html":{"url":"books/3.6sw.html","title":"单选和复选矿","keywords":"","body":"3.6 单选和复选 3.6.1 单选和复选 单选和复选很简单，只需要一个value和一个属性来维护每个选择框的value即可。 class BaseSwitch extends StatefulWidget { @override State createState() { return BaseSwitchState(); } } class BaseSwitchState extends State { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('弹框'), ), body: Container( margin: EdgeInsets.all(30), child: _body(), ), ); } bool _state1 = false, _state2 = true, _s3 = true, _s4 = false; Widget _body() { Widget w = Column( children: [ Container( height: 30, child: Text('CupertinoSwitchState:$_state1'), ), CupertinoSwitch( value: _state1, onChanged: (v) { setState(() { _state1 = v; }); }, ), Container( height: 30, child: Text('SwitchStates:$_state2'), ), Switch( value: _state2, onChanged: (v) { setState(() { _state2 = v; }); }, ), Container( height: 30, child: Text('Checkbox'), ), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Checkbox( value: _s3, onChanged: (v) { setState(() { _s3 = v; }); }, ), Checkbox( value: _s4, onChanged: (v) { setState(() { _s4 = v; }); }, ) ], ) ], ); return w; } } 效果如下： 属性和外观 Switch和CheckBox属性很简单，可以设置value来控制是否被选中，需要父级控件来维护,状态改变时也是父级来维护,另外还可以设置activeColor激活颜色，和normal状态的颜色trackColor。 这样子设计组件的好处是，交互交给外部，自己只处理样式，这样子传递的信息可以更灵活。 Copyright © ifgyong 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 17:52:52 "}}