{"./":{"url":"./","title":"简介","keywords":"","body":"Flutter 入门与进阶 "},"books/3.2state.html":{"url":"books/3.2state.html","title":"3.2：状态管理","keywords":"","body":"状态管理 3.2.1 状态管理 简介 Widget分为有状态和无状态，有状态的则就需要有人来管理了，父组件管理和自己管理各有什么优劣呢？ 如果状态是用户数据，如：复选框、滑块位置、最好有父组件管理。 如果状态是有关界面的效果，例如颜色、动画、最好由自己管理。 如果某一个状态是不同的Widget共享，则最好是父组件管理。 在组件内部管理，封装性当然是好一点，而缺少了灵活性，在父组件中管理子组件的状态，则更灵活，设计组件的时候，应已灵活多变为要点，多位父组件管理。 接下来我们用几个例子分别演示自己管理、父管理、多组件管理来说明状态管理不同方式。 我们使用一个简单的例子：一个盒子，活跃状态是红色，不活跃是灰色. 自己管理状态 自己管理状态，外界无需参与即可完成完整步骤，完全封闭。 class TapBox extends StatefulWidget { TapBoxState createState() => TapBoxState(); } class TapBoxState extends State { bool _selected = false; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('自己管理状态'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Container( color: _selected ? Colors.red : Colors.black12, child: FlatButton( child: Text(_selected ? 'Active' : 'Inactive'), onPressed: _tap, ), ) ], ), ), ); } void _tap() { setState(() { _selected = !_selected; }); } } 效果: 父组件管理 父组件可以指定子组件的状态，当条件复杂的时候，提交数据到服务后台，失败了，这种情况就用父组件来传递状态到子组件。 /// 封装好的子组件 class TapBox2 extends StatefulWidget { final bool selected; final onChange onchange; TapBox2({Key key, this.selected, this.onchange}) : super(key: key); TapBoxState2 createState() => TapBoxState2(); } typedef onChange = Function(bool); class TapBoxState2 extends State { bool _selected; @override void initState() { _selected = widget.selected == true; super.initState(); } @override Widget build(BuildContext context) { return Container( color: widget.selected == true ? Colors.red : Colors.black12, child: FlatButton( child: Text(widget.selected == true ? 'Active' : 'Inactive'), onPressed: _tap, ), ); } void _tap() { if (widget.onchange != null) { _selected = !_selected; widget.onchange(_selected); } } } /// 父组件来管理 class TapBox extends StatefulWidget { TapBoxState createState() => TapBoxState(); } class TapBoxState extends State { bool _selected = false; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('管理状态'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Container( color: _selected ? Colors.red : Colors.black12, child: TapBox2( onchange: (v) { setState(() { _selected = v; }); }, selected: _selected, ), ) ], ), ), ); } } 效果： 混合管理 有些组件，混合方式比较适用，这种情况，组件自身管理一部分状态，父组件管理一些外部状态。 下面的例子是不活跃状态按下盒子周围显示红色边框，活跃状态按下显示蓝色边框，抬起时边框消失，点击完成后，状态进行改变。活跃状态由外部管理,边框变化有内部管理。 class TapBox3 extends StatefulWidget { final bool selected; final onChange onchange; TapBox3({Key key, this.selected, this.onchange}) : super(key: key); TapBoxState3 createState() => TapBoxState3(); } class TapBoxState3 extends State { bool _touching = false; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return Container( child: GestureDetector( child: Container( height: 50, width: 120, alignment: Alignment.center, child: Text(widget.selected == true ? 'Active' : 'Inactive'), decoration: new BoxDecoration( color: widget.selected == true ? Colors.red : Colors.black12, border: _touching ? Border.all( color: widget.selected == false ? Colors.red : Colors.blue, width: 4) : null), ), onTap: _tap, onTapDown: (TapDownDetails details) { _touchStart(); }, onTapUp: (detail) { _touchend(); }, ), ); } void _tap() { if (widget.onchange != null) { widget.onchange(!widget.selected); } } void _touchStart() { setState(() { _touching = true; }); } void _touchend() { setState(() { _touching = false; }); } } /// 父组件管理活跃状态 Container( color: _selected ? Colors.red : Colors.black12, child: TapBox3( onchange: (v) { setState(() { _selected = v; }); }, selected: _selected, ), ) 效果： 3.2.2 全局状态管理 当跨页面状态管理的时候，上面的情况已经不适用，我们可以采用eventBus来进行数据传递，或者使用Provider进行数据管理和页面刷新。 自己管理或者父级管理本质是可以调用State的setState((){})进行Widget的build函数，当这些组件不在一个页面，则无法进行直接通信，这时我们有2中方法解决。 实现一个全局的时间总线，将状态对应一个事件，然后在对应的Widget进行刷新。 使用专门管理状态的包，如Provider、Redux，详细用法见pub 在后续章节中会介绍状态管理的机制原理，再次不做累述。 "},"books/3.3textandstyle.html":{"url":"books/3.3textandstyle.html","title":"3.3：文本和样式","keywords":"","body":"文本和样式 3.1 Text and TextStyle text用于显示简单的文字和样式，下面看下简单的例子 Text('text HelloWord', textAlign: TextAlign.left,) Text( '加了style的文本', style: TextStyle( color: Colors.red, fontSize: 30, height: 1.4, background: new Paint()..color = Colors.black12, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy), ) 效果如下： 一个是简单的文本显示，属性 textAlign:TextAlign.left 好像没起作用，原因是文本没超过一行，没效果。 底部波纹代码如下： decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy 这三行的样式是在底部添加了波纹线，SDK一共给了4中线的样式， enum TextDecorationStyle { /// Draw a solid line solid, /// Draw two lines double, /// Draw a dotted line dotted, /// Draw a dashed line dashed, /// Draw a sinusoidal line wavy } 效果如下： 喜欢哪一个随意挑选哦。 当文本超过一行的话可以截断或者换行 用到了属性TextOverflow Text( 'TextOverflow.visible' * 10, textAlign: TextAlign.left, maxLines: 1, overflow: TextOverflow.visible, ) 官方提供了四种方式，在设置maxLines=2效果如下 默认maxLines是无限的，自动换行的。如果设置固定行数，则文本最多不超过该行数，超过该行数则被截断，截断方式如上图所示。系统还提供了文字间隔wordSpacing和字符间隔letterSpacing，字体放大倍数textScaleFactor,如果不设置 ，会 MediaQueryData.textScaleFactor获取，默认是1.0。 3.2. TextSpan 首先看一个简单例子： TextSpan( text: 'Jok Ma,hello!', style: TextStyle( fontSize: 20, ), children: [ TextSpan( text: 'Bo', style: TextStyle( fontSize: 20, color: Colors.blue, backgroundColor: Colors.black12)), TextSpan( text: 'b,hello!', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent)), TextSpan( text: 'two line', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.double)), TextSpan( text: '\\n点击打开我 🖱http://www.fgyong.cn', style: TextStyle(fontSize: 20, height: 2), recognizer: new TapGestureRecognizer()..onTap = () { _openUrl('http://www.fgyong.cn'); }, ), ]), ), //是否打开url void _openUrl(String url) async { if (await canLaunch(url)) { await launch(url); } else { throw 'could not launch $url'; } } 效果如下： 这里使用了TextSpan组件，和Text类似的都有style，这一点完全一致，不同的是TextSpan可以添加children,这是一个数组，可以连续添加很多TextSpan,每个都可以单独设置样式，比如一个手机号，一个网址，。。可以通过recognizer: new TapGestureRecognizer()..onTap = _openUrl来实现点击文本跳转_openUrl函数，这给文本带来了更多的可能性。 height属性是计算方式是fontSize * height，默认是1.0，设置字体大小还有一个属性是textScaleFactor，这个是计算方式是fontSize * textScaleFactor,默认是1.0. fontSize字体具体的大小 height 行高 textScaleFactor，本质是fontSize * textScaleFactor,默认是1.0 * fontSize 3.3 DefaultTextStyle 可以被继承的TextStyle,当一个子树基本样式类似，可以使用DefaultTextStyle DefaultTextStyle( //1.设置文本默认样式 style: TextStyle( color: Colors.blue, fontSize: 30.0, ), textAlign: TextAlign.start, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(\"Jack Ma\"), Text(\"I am Ok\"), Text( \"I am Jack\", style: TextStyle( inherit: false, //2.不继承默认样式 color: Colors.grey), ), ], ), ) 效果如下： 这里边默认样式是字体大小30(逻辑像素),然后通过DefaultTextStyle设置子树的样式，这样子所有子树中的样式都遵从该样式，可以通过inherit: false显示指定不继承该样式。 3.3.4 字体 当开发人员想使用自定义(非默认)字体,可以去Google下载，则可以通过pubspec.yml中声明他，然后将字体移动到目录下fonts下： 然后在pubspec.yml的声明如下： fonts: - family: Merriweather fonts: - asset: fonts/Merriweather-Black.ttf - asset: fonts/Merriweather-Light.ttf weight: 700 这样子就可以在textStyle中使用了 TextStyle(fontFamily: 'Merriweather',) 或者在主题中直接声明默认的字体 ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, fontFamily: 'Merriweather') 更多字体设置见官网 如果想省事可以使用google_fonts. "},"books/3.4button.html":{"url":"books/3.4button.html","title":"3.4：按钮","keywords":"","body":"3.4 按钮 3.4.1 Material组件库的按钮 Material 组件库中提供了多种按钮组件如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton组件的包装定制，所以他们大多数属性都和RawMaterialButton一样。而RawMaterialButton是对InkWell的封装，涟漪效果也是该组件实现，如果想自己封装涟漪组件，继承该组件即可。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现波纹的动画）。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 FlatButton FlatButton是一个扁平按钮，在默认背景透明无阴影，按下后有深色背景，如图： 使用起来很简单： FlatButton( child: Text('nomal'), onPressed: () {},), RaisedButton RaisedButton是漂浮按钮，默认带有背景和阴影，活跃状态按钮背景变大，如图所示 IconButton IconButton默认是icon作为widget，背景透明，按压状态下，波纹状，背景变大。如图所示 FloatingActionButton FloatingActionButton即是悬浮按钮，默认背景是主题色，按压也会有波纹。右边是按压，左边是正常状态。 使用例子： FloatingActionButton(child: Icon(Icons.add), onPressed: () {}, ) BackButton CloseButton 官方封装好的返回和关闭按钮,如图： 使用例子: BackButton(onPressed: () {},), CloseButton(onPressed: () {},), OutlineButton OutlineButton带边框的按钮，默认有灰色边框，按压下边框高亮，可以同时兼备icon和label,如图： 使用也很简单： OutlineButton( child: Text('OutlineButton'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('label'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('active'), onPressed: () {}, ) 自定义按钮外观 外观可以通过属性来定义，不同按钮基本一样，我们以IconButton为例子，介绍一下常用属性，详细的可以查看官方文档。 textColor : 文本和icon的颜色 disabledBorderColor: 不点击状态下的边框颜色 highlightedBorderColor： 点击状态下边框颜色 splashColor:波纹颜色 borderSide：边框宽度和颜色 示例： 代码如下： OutlineButton.icon( onPressed: () {}, icon: Icon(Icons.add), label: Text('diy style'), color: Colors.black12, textColor: Colors.blue, disabledBorderColor: Colors.black, highlightedBorderColor: Colors.greenAccent, splashColor: Colors.red ) 如何自己实现一个Button,在后续章节中会再次详细讲到，在此不过多累述。 "},"books/3.5img.html":{"url":"books/3.5img.html","title":"3.5：图片和Icon","keywords":"","body":"3.5 图片及Icon 3.5.1 图片 Flutter中，我们可以通过image加载并显示图片，数据源可以是asset、file、内存、网络。 Image imageWidget有一个必选的参数，对应了一个ImageProvider,下边我们来演示一下image的使用。 从assets加载 首先将文件复制到工程指定文件夹内，我们移动至img文件夹下， 然后在pubpspec.yaml内声明 assets: - img/1.jpeg 然后运行flutter pub get,(或者 android studio 中编辑 pubpspec.yaml点击右上角pub get按钮)。 然后代码中可以使用了，实例: Image.asset('img/1.jpeg') 效果如图所示： 从网络加载 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, ) 或者使用快捷的构造函数Image.network用于从网络加载、显示图片 Image.network( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\", width: 120, ), 参数 Image在显示图片是定义了一系列参数，通过定义一系列参数达到改变图片外观、大小、混合效果等，我们看下Image的主要参数： const Image({ ... this.width, //图片的宽 this.height, //图片高度 this.color, //图片的混合色值 this.colorBlendMode, //混合模式 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ... }) width、height ：用户设置图片大小，当不指定大小，图片则在富容器内进行占满，当设置width或height时，另外一个会按照比例缩放，但可以通过fit来指定缩放规则。 fit:指定图片在容器内的缩放规则。有如下几个值 fill:会拉伸铺满，图片会变形 cover: 按照图片的长宽放大后填满容器，不会变形。 fitWidth: 图片会随着缩放到显示的宽度，在保证不变形的条件下进行适应宽度,超出部分会裁剪。 fitHeight:图片高度会按照等比例缩放到适应高度，超出部分会裁剪。 none: 无适应规则，会显示当前容器的大小，如果图片过大，则只会显示中间部分。 看图，简单明了： color指定混合颜色，colorBlendMode指定混合模式。 例子： Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, ) 效果： repeat是当图片不够容器大小可以设置沿着X或者Y进行重复铺。 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, height: 200, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, repeat: ImageRepeat.repeat, ) 效果： Image 从网络下载动画 Image从网络下载会与短暂的 空白时间，这是我们不想看到的，我们可以在加载的时候显示菊花转。 Image( image: NetworkImage( \"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2053400745,529716701&fm=26&gp=0.jpg\"), width: 100.0, height: 200, loadingBuilder: ( BuildContext context, Widget child, ImageChunkEvent loadingProgress, ) { if (loadingProgress == null) { return child; } return CircularProgressIndicator(); }, ) 效果如图所示： 3.5.2 Icon flutter中可以使用iconFont，就是将图标做成文件，通过指定字符加载不同icon. 字体文件中，每一个字符都对应一个位码，不同字体就是字形不同，即字符对应的字形不同，最终渲染的不同的图标。 Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下 uses-material-design: true Material Design所有图标可以在其官网查看. 例子： Text('\\uE915 \\uE002 \\uE900', style: TextStyle( fontFamily: \"MaterialIcons\", fontSize: 24.0, color: Colors.green)) 效果： 对着code 找图标明显不是太人性化，那么可以使用cupertino_icons Icon( Icons.clear, color: Colors.red, ), Icon( Icons.add, color: Colors.greenAccent, ), Icon( Icons.collections, color: Colors.blue, ), Icon( Icons.extension, color: Colors.orange, ) 使用自定义字体图标 我们也可以使用自定义字体图标。iconfont.cn上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在Flutter中，我们使用ttf格式即可。 假设我们项目中需要使用一个书籍图标和微信图标，我们打包下载后导入： 导入字体图标文件；这一步和导入字体文件相同，假设我们的字体图标文件保存在项目根目录下，路径为\"fonts/iconfont.ttf\"： fonts: - family: myIcon #指定一个字体名 fonts: - asset: fonts/iconfont.ttf 为了使用方便，我们定义一个MyIcons类，功能和Icons类一样：将字体文件中的所有图标都定义成静态变量： class MyIcons{ // book 图标 static const IconData book = const IconData( 0xe614, fontFamily: 'myIcon', matchTextDirection: true ); // 微信图标 static const IconData wechat = const IconData( 0xec7d, fontFamily: 'myIcon', matchTextDirection: true ); } 使用 Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(MyIcons.book,color: Colors.purple,), Icon(MyIcons.wechat,color: Colors.green,), ], ) 运行后效果如图3-22所示： "},"books/3.6sw.html":{"url":"books/3.6sw.html","title":"3.6：单选和复选矿","keywords":"","body":"3.6 单选和复选 3.6.1 单选和复选 单选和复选很简单，只需要一个value和一个属性来维护每个选择框的value即可。 class BaseSwitch extends StatefulWidget { @override State createState() { return BaseSwitchState(); } } class BaseSwitchState extends State { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('弹框'), ), body: Container( margin: EdgeInsets.all(30), child: _body(), ), ); } bool _state1 = false, _state2 = true, _s3 = true, _s4 = false; Widget _body() { Widget w = Column( children: [ Container( height: 30, child: Text('CupertinoSwitchState:$_state1'), ), CupertinoSwitch( value: _state1, onChanged: (v) { setState(() { _state1 = v; }); }, ), Container( height: 30, child: Text('SwitchStates:$_state2'), ), Switch( value: _state2, onChanged: (v) { setState(() { _state2 = v; }); }, ), Container( height: 30, child: Text('Checkbox'), ), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Checkbox( value: _s3, onChanged: (v) { setState(() { _s3 = v; }); }, ), Checkbox( value: _s4, onChanged: (v) { setState(() { _s4 = v; }); }, ) ], ) ], ); return w; } } 效果如下： 属性和外观 Switch和CheckBox属性很简单，可以设置value来控制是否被选中，需要父级控件来维护,状态改变时也是父级来维护,另外还可以设置activeColor激活颜色，和normal状态的颜色trackColor。 这样子设计组件的好处是，交互交给外部，自己只处理样式，这样子传递的信息可以更灵活。 CheckboxListTile CheckboxListTile是官方控件，像一个按钮一样，点击任一地方都可以实现选择和取消选择，还可以添加icon，可以控制CheckBox的位置。 我们看下属性： const CheckboxListTile({ ... @required this.value, @required this.onChanged, this.activeColor, this.checkColor, this.title, this.subtitle, this.isThreeLine = false, this.dense, this.secondary, this.selected = false, this.controlAffinity = ListTileControlAffinity.platform, }) value是有选中状态，由父组件来维护 onChanged是状态改变回调函数 activeColor 选中状态颜色 checkColor 选中状态✔️的颜色 dense如果为null，就使用主题ListTileTheme.dense secondary和Checkbox对称的组件，可以是一个Icon isThreeLine 是否是强制显示三行 subtitle子标题 selected是否选中，默认是false controlAffinity 是CheckBox 的位置 controlAffinity memo leading checkbox在左边 trailing checkbox在右边 platform checkbox典型的样式 例子： CheckboxListTile( onChanged: (v) { setState(() { _checkList2 = v; }); }, title: Text('checkListTitle box is trailing'), value: _checkList2, controlAffinity: ListTileControlAffinity.leading, ), 效果： 外观 可以给小部件添加icon和子主题，icon一般和checkbox在对称的位置，子主题在主题的下边，当使用默认主题ListTileTheme.dense,文字部件会自动使用系统的样式。 例子： CheckboxListTile( onChanged: (v) { setState(() { _checkList1 = v; }); }, title: Text('checkListTitle box is leading'), value: _checkList1, controlAffinity: ListTileControlAffinity.leading, secondary: Icon(Icons.message), activeColor: Colors.orange, checkColor: Colors.blue, subtitle: Text('我是subtitle'), dense: true, ), 效果： RadioListTile RadioListTile和CheckboxListTile属性基本一致，最大的不同是前者只能由未选中该为选中，选中之后不能继续操作，也就是不能再次点击实现反选功能。 CheckboxListTile( onChanged: (v) { setState(() { _checkList2 = v; }); }, title: Text('checkListTitle box is trailing'), value: _checkList2, secondary: Icon(Icons.message), controlAffinity: ListTileControlAffinity.leading, ), 如果觉得不是很方便，可以自定义一个类似这个样式的小部件，我们下边实现一个选中之后可以反选的RadioWidget. class LinkedLabelRadio extends StatelessWidget { const LinkedLabelRadio({ this.label, this.padding, this.groupValue, this.value, this.onChanged, }); final String label; final EdgeInsets padding; final bool groupValue; final bool value; final Function onChanged; @override Widget build(BuildContext context) { return Padding( padding: padding, child: Row( children: [ Radio( groupValue: groupValue, value: value, onChanged: (bool newValue) { onChanged(newValue); }), RichText( text: TextSpan( text: label, style: TextStyle( color: Colors.blueAccent, decoration: TextDecoration.underline, ), recognizer: TapGestureRecognizer() ..onTap = () { print('Label has been tapped.'); }, ), ), ], ), ); } } ///-------------build widget---------------------- /// 添加到build 中 /// 还需要父组件来维护一个 _isRadioSelected bool _isRadioSelected = false; LabeledRadio( label: 'This is the first label text', padding: const EdgeInsets.symmetric(horizontal: 5.0), value: true, groupValue: _isRadioSelected, onChanged: (bool newValue) { setState(() { _isRadioSelected = newValue; }); }, ), 效果： 再封装一个附带超链接的Radio,点击超链接，执行回调函数，点击其他区域，执行selected状态变更。 class LinkedLabelRadio extends StatelessWidget { const LinkedLabelRadio({ this.label, this.padding, this.groupValue, this.value, this.onChanged, }); final String label; final EdgeInsets padding; final bool groupValue; final bool value; final Function onChanged; @override Widget build(BuildContext context) { return Padding( padding: padding, child: Row( children: [ Radio( groupValue: groupValue, value: value, onChanged: (bool newValue) { onChanged(newValue); }), RichText( text: TextSpan( text: label, style: TextStyle( color: Colors.blueAccent, decoration: TextDecoration.underline, ), recognizer: TapGestureRecognizer() ..onTap = () { print('Label has been tapped.'); }, ), ), ], ), ); } } /// ----------------widget----------------- LinkedLabelRadio( label: 'First tappable label text', padding: EdgeInsets.symmetric(horizontal: 5.0), value: true, groupValue: _isRadioSelected2, onChanged: (bool newValue) { setState(() { _isRadioSelected2 = newValue; }); }, ), LinkedLabelRadio( label: 'Second tappable label text', padding: EdgeInsets.symmetric(horizontal: 5.0), value: false, groupValue: _isRadioSelected2, onChanged: (bool newValue) { setState(() { _isRadioSelected2 = newValue; }); }, ), 效果： 更多自定义组装在后续章节中会一一讲解，再次不过多累述。 "},"books/3.7textfield.html":{"url":"books/3.7textfield.html","title":"3.7：输入框","keywords":"","body":"3.7 输入框和表单 输入框有TextField、带有iOS风格的CupertinoTextField,还有表单form. 3.7.1 TextField TextField默认带有下划线，无边框的，属性InputDecoration可以设置默认文字，当编辑状态，文字已动画形式上浮至左上角，这是其他输入框所没有的。其他的看下属性： const TextField({ ... this.controller, this.focusNode, this.decoration = const InputDecoration(), TextInputType keyboardType, this.textInputAction, this.style, this.textAlign = TextAlign.start, this.textAlignVertical, this.textDirection, this.showCursor, this.autofocus = false, this.obscureText = false, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorRadius, this.cursorColor, ... }) controller可以获取文字和设置文字， focusNode 获取焦点 keyboardType键盘类型 textInputAction输入键盘右下角的键 onChanged 当textField的value变化回调函数 onSubmitted提交按键 obscureText true则显示原点，否则显示原文字 cursorWidth光标宽度 cursorRadius 光标圆圈半径 cursorColor光标颜色 textInputAction有多个值，具体见下表格： textInputAction 备注 none Android是IME_ACTION_NONE,iOS没有 unspecified Android's IME_ACTION_UNSPECIFIED,iOS 是return done Android's IME_ACTION_DONE iOS是done go android and iOS 都是go search android and ios is Search send android and ios is send next android and ios is next previous iOS没有，Android's IME_ACTION_PREVIOUS continueAction Android没有，iOS上是contion join android and ios is join route android没有，ios is route emergencyCall android没有，ios is Emergency Call newline android and ios都没有，只是方便开发人员调试 例子： _focusNode = new FocusNode(); _editingController = new TextEditingController(); _field = TextField( focusNode: _focusNode, onChanged: (v) { setState(() {}); }, onSubmitted: (v) { _focusNode.unfocus(); }, controller: _editingController, obscureText: false, //是否是密码 decoration: InputDecoration(hintText: '手机号', labelText: '手机号'), keyboardType: TextInputType.number, ); Column( children: [ Text('TextField'), _field, Text(_editingController.value.text), ], ) 效果如下： iOS-style的组件CupertinoTextField,属性和TextField基本一致; 例子： _editingController2 = new TextEditingController(); _focusNode2 = new FocusNode(); _cupertinoTextField = CupertinoTextField( focusNode: _focusNode2, controller: _editingController2, placeholder: '密码', prefix: Icon(Icons.lock), textInputAction: TextInputAction.go, obscureText: true, ); Column( children: [ SizedBox( height: 30, ), Text('CupertinoTextField'), _cupertinoTextField, ], ) 效果： 监听文本变化 _editingController = new TextEditingController() ..addListener(() { print(\"${_editingController.value.text}\"); }); 或者 TextField( focusNode: _focusNode, onChanged: (v) { print('onChange$v'); }, controller: _editingController, ... ); 收键盘 TextField( focusNode: _focusNode, ); /// 收键盘 _focusNode.unfocus(); 收键盘之前必须在初始化的时候赋值给TextField,另外官方还提供了编辑下一个textField,当下边没有可以提供编辑的textField则进行书键盘操作，有的话则跳至下一个textField. _focusNode.focusInDirection(TraversalDirection.down); 3.7.2 Form Form更新数据和获取数据需要使用_globalKey获取当前的State。 例子： Form( key: _globalKey, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ TextFormField( decoration: const InputDecoration( hintText: 'Enter your email', ), validator: (value) { if (value.isEmpty) { return 'Please enter some text'; } return null; }, ), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: RaisedButton( onPressed: () { // Validate will return true if the form is valid, or false if // the form is invalid. if (_globalKey.currentState.validate()) { // Process data. } }, child: Text('Submit'), ), ), ], ), ) Form子树中可以是多个TextFormField,每个可以单个校验，所有的都校验过了，FormState才是校验通过的，多用于多输入校验。那么我们写一个登陆的简单校验。 例子： _form = Form( key: _globalKey, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ TextFormField( decoration: const InputDecoration( hintText: 'Enter your email', icon: Icon(Icons.mail)), validator: (value) { if (value.isEmpty) { return 'Please enter some text'; } return null; }, ), TextFormField( controller: _editingController3, decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", icon: Icon(Icons.lock)), obscureText: true, //校验密码 validator: (v) { return v.trim().length > 5 ? null : \"密码不能少于6位\"; }), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: RaisedButton( onPressed: () { // Validate will return true if the form is valid, or false if // the form is invalid. if (_globalKey.currentState.validate()) { // Process data. print('校验通过'); } setState(() { _done = _globalKey.currentState.validate(); }); }, child: Text('Submit'), ), ), ], ), ); "},"books/3.8indicator.html":{"url":"books/3.8indicator.html","title":"3.8: 进度指示器","keywords":"","body":"3.8 进度指示器 Material组件库中提供了两种进度指示器：LinearProgressIndicator和CircularProgressIndicator，它们都可以同时用于精确的进度指示和模糊的进度指示。精确进度通常用于任务进度可以计算和预估的情况，比如文件下载；而模糊进度则用户任务进度无法准确获得的情况，如下拉刷新，数据提交等。 3.8.1 LinearProgressIndicator LinearProgressIndicator线形的进度指示器，看文档如下： const LinearProgressIndicator({ Key key, double value, Color backgroundColor, Animation , String semanticsLabel, String semanticsValue, }) value默认为null，效果为动画,范围是[0,1] backgroundColor是动画背景颜色，为静态的 valueColor是动画前景色，可以使用AnimationController搭配达到颜色变化的目的。也可以使用AlwaysStoppedAnimation来达到静态颜色。 例子： LinearProgressIndicator( valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.black12, ) 效果： 设置大小和线条宽度： SizedBox( height: 20, width: 200, child: LinearProgressIndicator( // value: 0.1, valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.black12, ), ), 效果： CircularProgressIndicator CircularProgressIndicator是原型进度指示器，可以自己配置颜色和进度，相关属性紧紧比LinearProgressIndicator多了一个线条宽度strokeWidth. 相关属性： CircularProgressIndicator({ ... double value, Color backgroundColor, Animation valueColor, this.strokeWidth = 4.0 ... }) value默认为null，效果为动画,范围是[0,1] backgroundColor是动画背景颜色，为静态的 valueColor是动画前景色，可以使用AnimationController搭配达到颜色变化的目的。也可以使用AlwaysStoppedAnimation来达到静态颜色。 this.strokeWidth默认为4，可以自定单独设置。 例子： CircularProgressIndicator( valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.greenAccent, ) 效果： 自定义外观 通过strokeWidth定义线条宽度，通过valueColor定义渐变色,backgroundColor定义背景色。 例子： AnimationController _controller; @override void initState() { _controller = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)) ..repeat(); super.initState(); } SizedBox( height: 200, width: 200, child: CircularProgressIndicator( valueColor: ColorTween(begin: Colors.grey, end: Colors.orange) .animate(_controller), backgroundColor: Colors.black12, strokeWidth: 10, ), ), 效果： 更多进度指示器 和好网的样式可以参考flutter_easyHub 进度条 利用value可以定制，可以用在下载进度指示器上。 例子： AnimationController _controller; Timer _timer; double _value = 0; @override void initState() { _controller = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)) ..repeat(); _timer = Timer.periodic(Duration(milliseconds: 16), (t) { _value += 0.01; if (_value >= 1.0) { _value = 0; } setState(() {}); }); super.initState(); } SizedBox( height: 200, width: 200, child: Stack( children: [ Positioned.fill( child: CircularProgressIndicator( valueColor: ColorTween(begin: Colors.blue, end: Colors.orange) .animate(_controller), backgroundColor: Colors.black12, strokeWidth: 10, value: _value, ), ), Positioned.fill( child: Center( child: Text( '${(_value * 100).toDouble().toStringAsFixed(2)}%', style: TextStyle(fontSize: 20, color: Colors.orange), ), )) ], ), ), 效果： "},"books/3.9dialog.html":{"url":"books/3.9dialog.html","title":"3.9: 弹窗","keywords":"","body":"3.9 弹窗 组件库中提供了多种弹窗适用于选择时间、定时、用户选择、表单提交等。。。 3.9.1 showCupertinoDialog showCupertinoModalPopup是一个iOS-style风格的弹窗，从底部弹出，附带了一个唯一动画和渐变消失的动画，按钮也是iOS-style风格，点击遮罩返回。下面看下代码： 例子： void _showActionSheet() { showCupertinoModalPopup( context: context, builder: (ctx) { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是支付选项，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); }); } 效果： 3.9.2 showCupertinoDialog showCupertinoDialog是对showGeneralDialog的一个封装，只是barrierDismissible、barrierColor、transitionDuration进行了iOS-style格调的设置。 源码： Future showCupertinoDialog({ @required BuildContext context, @required WidgetBuilder builder, bool useRootNavigator = true, RouteSettings routeSettings, }) { assert(builder != null); assert(useRootNavigator != null); return showGeneralDialog( context: context, barrierDismissible: false, barrierColor: CupertinoDynamicColor.resolve(_kModalBarrierColor, context), // This transition duration was eyeballed comparing with iOS transitionDuration: const Duration(milliseconds: 250), pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return builder(context); }, transitionBuilder: _buildCupertinoDialogTransitions, useRootNavigator: useRootNavigator, routeSettings: routeSettings, ); } 和showCupertinoModalPopup区别是一个从底部，一个全屏。 下面看下例子； showCupertinoDialog( context: context, builder: (ctx) { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是showCupertinoDialog'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); }); 效果： 3.9.3 showAboutDialog showAboutDialog是flutter官方封装的一个关于我的组件，包含了版本号、icon、以及Licenses内容。 例子： showAboutDialog( context: context, applicationVersion: '1.0.0', applicationIcon: Icon(Icons.scatter_plot), applicationName: 'Jack ma', ); 3.9.4 showGeneralDialog showGeneralDialog是一个比较基础的弹窗， 可以用这个封装成任意其他的弹窗。 例子： showGeneralDialog( context: context, barrierDismissible: true, barrierLabel: 'cancel', transitionDuration: Duration(milliseconds: 1000), pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return Material( child: Scaffold( body: Center( child: CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是showGeneralDialog，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction( onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction( onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ), ), ), ); }); 效果： 3.9.4 showDialog showDialog也是封装的showGeneralDialog,只是固定参数进行了适配。 void _showDialog() { showDialog(context: context, child: bd()); } Widget bd() { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是支付选项，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); } 3.9.6 showDatePicker showDatePicker是官方提供的一个日历组件，也是座位弹窗形式展现，参数很简单。 showDatePicker({ @required BuildContext context, @required DateTime initialDate, @required DateTime firstDate, @required DateTime lastDate ... } 只需要配置当前的上下文和开始结束时间即可。 例子： showDatePicker( context: this.context, initialDate: DateTime.now(), //初始时间 firstDate: DateTime.now(), //开始时间 lastDate: DateTime.now().add(Duration(days: 10)), //最后时间是当前时间加上10天 initialDatePickerMode: DatePickerMode.year, //最开始展示年份 initialEntryMode: DatePickerEntryMode.input, //开始是输入时间还是日历 selectableDayPredicate: (time) { print(time.toString()); return true; }) 效果： 3.9.7 showTimePicker showTimePicker是一个选择时间长短的控件,使用起来很简单，只需要传入默认时间即可。 showTimePicker( context: this.context, initialTime: TimeOfDay(hour: 1, minute: 10)) 效果： "},"books/4.1layoutdesc.html":{"url":"books/4.1layoutdesc.html","title":"4.1 布局类组件简介","keywords":"","body":"4.1 布局简介 布局类组件都会包含一个或者多个子组件，不同的布局类组件对子组件的排列方式不同，排版最终会通过Element树才是最终的绘制树，Element是通过Widget.createElement创建的，Widget是Element的配置数据，在Flutter中，根据Widget是否需要包含子节点将Widget分为三类，如下： Widget Element 用途 LeafRenderObjectWidget LeafRenderObjectElement Widget的叶子节点(叶子就是没有孩子的节点),一般用于基础组件如Image、 SingleChildRenderObjectWidget SingleChildRenderObjectElement 包含一个子组件，如:Container,Align... MultiChildRenderObjectWidget MultiChildRenderObjectElement 包含一个或多个子组件，如：Row,Column,Stack... b布局类组件就是指直接或者间接(包含)MutiChildRenderObjectWidget的Widget，他们一般有child属性用来接收子组件，Widget>RenderObjectWidget>(Leaf/SingleChild/MutiChild)RenderObjectWidget RenderObjectWidget类定义了创建、更新RenderObject的方法，子类必须实现他们，关于RenderObject我们现在只需要知道他是最终布局，渲染UI界面即可，也就是说，布局类算法都是通过RenderObject对象来实现的，所以读者接下来对布局类组件原理感兴趣可以自行查看RenderObject的实现。 "},"books/4.2rowandcolumn.html":{"url":"books/4.2rowandcolumn.html","title":"4.2 线性布局（Row和Column","keywords":"","body":"4.2 线性布局（Row、Column） Row、 Column是线性布局，通俗的来讲就是按照横轴或者纵轴来布局，他们可以相互嵌套实现负责的布局。 主轴和横轴 在线性布局中，分为纵轴和横轴,如果布局是水平分布，那么主轴是指水平方向；如果布局是垂直方向，那么主轴就是指垂直方向，而纵轴是水平方向。官方提供了两个枚举来表示来表示主轴MainAxisAlignment和纵轴CrossAxisAlignment. Row Row组件可以沿着水平排列组件，每一个Row都是一列，子组件依次排列。 Row({ Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List children = const [], }) mainAxisAlignment: 主轴的排列位置，如果文本方向是TextDirection.ltr,start,按照从左向右的开始方向排列,否则从右向左排列。center是按照中间向两边排列，end是按照从结尾向开始方向排列。spaceBetween是两个子组件间隔一致。spaceEvenly是所有的空隙一致。spaceAround开始和结束是中间的间隙的一半。默认是MainAxisAlignment.start. crossAxisAlignment 副轴方向，和主轴方向类似，start是排列在开始位置。end排列在底部。center排列在副轴中间。baseline根据基线排列，stretch要求他的子组件副轴方向充满父组件，默认是CrossAxisAlignment.center。 MainAxisSize:MainAxisSize.max是可用空间的最大值，大当然可用空间必须有约束，大小必须是能计算出来的，否则将崩溃。因为空间大小不可能是无限制的。 children:子部件数组。 例子 class BaseRowAndColumn extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('线性布局'), ), body: SafeArea( child: CupertinoScrollbar( child: SingleChildScrollView( child: Column( children: [ _body(MainAxisAlignment.start, CrossAxisAlignment.start), _body(MainAxisAlignment.end, CrossAxisAlignment.start), _body(MainAxisAlignment.spaceBetween, CrossAxisAlignment.start), _body(MainAxisAlignment.spaceEvenly, CrossAxisAlignment.start), _body(MainAxisAlignment.spaceAround, CrossAxisAlignment.start), _body(MainAxisAlignment.center, CrossAxisAlignment.start), _body(MainAxisAlignment.center, CrossAxisAlignment.start), _body(MainAxisAlignment.center, CrossAxisAlignment.stretch), _body(MainAxisAlignment.center, CrossAxisAlignment.end), ], ), ), ))); } Widget _body(MainAxisAlignment mainAxisAlignment, CrossAxisAlignment crossAxisAlignment) { return Container( margin: EdgeInsets.symmetric(vertical: 10), child: Column( children: [ Text('$mainAxisAlignment $crossAxisAlignment'), Container( height: 50, child: Row( mainAxisAlignment: mainAxisAlignment, crossAxisAlignment: crossAxisAlignment, children: [ Container( color: Colors.blue, child: Text('Hello,'), ), Container( color: Colors.red, child: Text('I am'), ), Container( color: Colors.orange, child: Text('Jack ma'), ), ], ), color: Colors.black12, ) ], ), ); } } 效果图： 展示了主轴的常用的效果： MainAxisAlignment:start是比较简单是排列是从开始到结束，end是主轴结尾开始排列，spaceBetween是间隙均匀分布(不包含左侧和右侧)，spaceEvenly所有间隙空间均匀分布(包含左侧和右侧),spaceAround所有间隙空间均匀分布(左侧和右侧占用中间间隙的一半) CrossAxisAlignment: start在顶部排列，end在底部排列，center在中间排列，stretch铺满父级空间排列。 Column Column是按照纵轴排列，每个组件占用一行空间。 Column({ Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List children = const [], }) 大多数参数和Row一致，不同的是主轴和纵轴方向正好相反，下面看一个例子： Widget _bd2() { return Column( children: [ _column(MainAxisAlignment.start, CrossAxisAlignment.start), _column(MainAxisAlignment.center, CrossAxisAlignment.start), _column(MainAxisAlignment.end, CrossAxisAlignment.start), _column(MainAxisAlignment.spaceAround, CrossAxisAlignment.start), _column(MainAxisAlignment.spaceEvenly, CrossAxisAlignment.start), _column(MainAxisAlignment.spaceBetween, CrossAxisAlignment.start), _column(MainAxisAlignment.start, CrossAxisAlignment.start), _column(MainAxisAlignment.start, CrossAxisAlignment.center), _column(MainAxisAlignment.start, CrossAxisAlignment.end), _column(MainAxisAlignment.start, CrossAxisAlignment.stretch), // _column(MainAxisAlignment.start, CrossAxisAlignment.start), ], ); } Widget _column(MainAxisAlignment mainAxisAlignment, CrossAxisAlignment crossAxisAlignment) { return Container( margin: EdgeInsets.symmetric(vertical: 20), color: Colors.black12, height: 105, child: Column( mainAxisAlignment: mainAxisAlignment, crossAxisAlignment: crossAxisAlignment, children: [ Text('$mainAxisAlignment $crossAxisAlignment'), Container( color: Colors.blue, child: Text('Hello,'), ), Container( color: Colors.red, child: Text('I am'), ), Container( color: Colors.orange, child: Text('Jack ma'), ), ], ), ); } 效果： 横轴和纵轴 效果 MainAxisAlignment.start, CrossAxisAlignment.start MainAxisAlignment.center, CrossAxisAlignment.start MainAxisAlignment.end, CrossAxisAlignment.start MainAxisAlignment.spaceAround, CrossAxisAlignment.start MainAxisAlignment.spaceEvently, CrossAxisAlignment.start MainAxisAlignment.spaceBeteen, CrossAxisAlignment.start MainAxisAlignment.start, CrossAxisAlignment.center MainAxisAlignment.start, CrossAxisAlignment.end MainAxisAlignment.start, CrossAxisAlignment.stretch 总的效果： Widget _bd3() { return Container( color: Colors.red, height: 100, child: Row( children: [ Container( width: 100, color: Colors.black, ), ], ), ); } 这里row中的子控件指定了width,高度没指定，默认是铺满高度 效果： 当row中嵌套了另外一个row则显示真实大小。原因是当子控件有真实大小，在row中则父组件未指定高度，则父组件高度和子组件高度一致。 Widget _bd3() { return Container( color: Colors.red, height: 100, child: Row( children: [ Container( width: 100, color: Colors.black, child: Row( children: [ Container( height: 50, width: 50, color: Colors.blue, ), ], mainAxisSize: MainAxisSize.max, )), ], ), ); } } 当我们想让一个子组件充满父组件则需要使用弹性控件包裹一下。弹性组件后边的章节会详细讲解，再次不多啰嗦了。 Widget _bd3() { return Container( color: Colors.red, height: 100, child: Row( children: [ Expanded( child: Container( margin: EdgeInsets.all(20), color: Colors.black, ), ), ], ), ); } 效果： 效果： 在Column空间充满父组件： Widget _bd3() { return Container( child: Column( children: [ Expanded( child: Container( margin: EdgeInsets.all(20), color: Colors.red, child: Text('Are you OK?'), ), ), ], ), ); } 效果图： 总结： Row和Column主轴和副轴完全相反，他们的主轴方向就是Row是横着的，Column是垂直的。多层嵌套的话，最好每层的组件都做好约束，想铺满父组件就是用弹性控件Expanded "},"books/4.3flex.html":{"url":"books/4.3flex.html","title":"4.3 弹性布局（Flex）","keywords":"","body":"4.3 弹性布局（Flex） Flex弹性布局，是常见的一种布局，他允许盒子按照一定比例来分配空间。 Flex Flex组件可以沿着水平或者垂直方向排列组件，如果你知道主轴方向，使用Row或Column可能会更方便点，因为Row和Column都是继承Flex,参数基本相同，所以Flex可以用的地方，基本Row和Column都可以满足要求。 Flex({ Key key, @required this.direction, this.mainAxisAlignment = MainAxisAlignment.start, this.mainAxisSize = MainAxisSize.max, this.crossAxisAlignment = CrossAxisAlignment.center, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline, List children = const [], }) direction: 指定Axis.vertical它就是Column，指定为Axis.horizontal它就是Row. mainAxisAlignment: 主轴的排列位置，如果文本方向是TextDirection.ltr,start,按照从左向右的开始方向排列,否则从右向左排列。center是按照中间向两边排列，end是按照从结尾向开始方向排列。spaceBetween是两个子组件间隔一致。spaceEvenly是所有的空隙一致。spaceAround开始和结束是中间的间隙的一半。 crossAxisAlignment 副轴方向，和主轴方向类似，start是排列在开始位置。end排列在底部。center排列在副轴中间。baseline根据基线排列，stretch要求他的子组件副轴方向充满父组件。 效果图： 展示了主轴的常用的效果： Expanded 可以按照比例扩展Row或者Column、Flex的所占空间。 Expanded({ Key key, int flex = 1, @required Widget child, }) 例子： Container( height: 30, child: Row(children: [ Expanded( flex: 1, child: Container( color: Colors.red, ), ), Expanded( flex: 2, child: Container( color: Colors.orange, ), ), Expanded( flex: 3, child: Container( color: Colors.blue, ), ) ])) 效果： Spacer const Spacer({Key key, this.flex = 1}) 源码也很简单，其实是封装了Expanded，主动添加了一个大小是0,0的SizedBox.shrink(). 例子： Container( height: 30, child: Row(children: [ Container( width: 50, color: Colors.red, ), Spacer( flex: 1, ), Container( width: 50, color: Colors.red, ), Spacer( flex: 2, ), Container( width: 50, color: Colors.red, ), ])) 效果： 实际应用 当我们想子组件随着用父组件变大而变大，屏幕变宽而变宽，那么请使用弹性布局. Row( children: [ Expanded( child: OutlineButton( child: Text('Expanded btn'), ), ) ], ), OutlineButton( child: Text('btn'), ), 效果： 如果距离左侧 或者右侧边距20px呢？ Row( children: [ SizedBox( width: 20, ), Expanded( child: OutlineButton( child: Text('Expanded btn'), ), ), SizedBox( width: 20, ), ], ) 效果图： 总结： 如果横着排列请用Row,如果横着有些随着屏幕变宽也变宽，使用Row+Expanded,如果固定间隔请使用SizedBox,如果间隔按照比例分配，请用Spacer 弹性布局比较简单，多用才能有更深理解。 "},"books/4.4wrap.html":{"url":"books/4.4wrap.html","title":"4.4 流式布局","keywords":"","body":"4.4 流式布局 流式布局就是瀑布一样的由上而下的依次排开的布局方式，我们称之为是流式布局。flutter中的流式布局是Wrap和Flow,当超过屏幕大小则进行换行操作。 Wrap Wrap({ ... this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List children = const [], }) direction 、alignment 、crossAxisAlignment 、textDirection 、children这些参数在前面已经讲过很多次了，再次便不重复讲解。 spacing : 主轴方向间隔 runSpacing : 副轴方向间隔 runAlignment : 副轴方向的排列位置 设置主轴间隔是20px,副轴方向间隔是30px,主轴居中WrapAlignment.center 例子： Widget _body() { return Wrap( alignment: WrapAlignment.center, spacing: 20.0, runSpacing: 30, // direction: Axis.vertical, children: [ _item('Are you ok ？', 'A'), _item('I am ok ', 'B'), _item('马什么？', 'C'), _item('什么梅？', 'D'), _item('马东什么？', 'E'), ], ); } 效果： 改成纵轴排列： Widget _body() { return Wrap( runAlignment: WrapAlignment.start, alignment: WrapAlignment.center, spacing: 20.0, runSpacing: 30, direction: Axis.vertical, children: [ _item('Are you ok ？', 'A'), _item('I am ok ', 'B'), _item('马什么？', 'C'), _item('什么梅？', 'D'), _item('马东什么？', 'E'), ], ); } 效果： Flow Flow相对于Wrap比较复杂，需要自己实现子组件的位置转换，所以使用流式布局则有限考虑Wrap，是否满足。Flow主要应用在自定义布局策略或性能要求高的场景，有点如下： 性能强劲；Flow是对于子组件以及位置调整非常高效的空间，Flow的转换矩阵对于子组件进行调整进行了优化，Flow定位之后，如果子组件位置或者尺寸发生了变化，在FlowDelegate中的PaintChild()方法调用context,paintChild()进行重绘，而在context.paintChild在重绘针具并没有调整组件位置。 灵活；可以自己实现FlowDelegate的paintChild()方法，需要自己计算每一个组件的位置。 缺点： 使用比较复杂 不能自适应组件大小，必须指定父容器大小或实现BaseFlowDelegate的getSize返回固定大小。 示例： 我们对刚才的子组件进行布局： class BaseFlowDelegate extends FlowDelegate { EdgeInsets margin; BaseFlowDelegate({this.margin = EdgeInsets.zero}); @override void paintChildren(FlowPaintingContext context) { var x = margin.left; var y = margin.top; //计算每一个子widget的位置 for (int i = 0; i _list() { return [ _item('Are you ok ？', 'A'), _item('I am ok ', 'B'), _item('马什么？', 'C'), _item('什么梅？', 'D'), _item('马东什么？', 'E'), ]; } 效果： 我们根据传入的Margin来计算每一个Child的具体位置，然后使用context.paintChild()来绘制出来。由于Flow不能适配父级大小，我们通过getSize来确定Flow大小。 "},"books/4.5stack.html":{"url":"books/4.5stack.html","title":"4.5 层叠布局 Stack、Positioned","keywords":"","body":"4.5 层叠布局 Stack、Positioned 4.5.1 Stack 层叠布局和iOS中的常用布局一致，iOSer很容易理解，子组件根据父组件的位置来确定自己的位置，父组件允许子组件一层一层叠起来，需要在添加的时候注意顺序，先添加的在底部，后添加的在上面。Stack允许子组件堆叠，Positioned用于根据Stack的四个角来确定自己的位置和大小。 Stack Stack({ Key key, this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List children = const [], }) alignment:和Align中的一致，现在只需要了解是相对于父组件的位置，具体的算法见4.6 相对定位. textDirection:和Row、Wrap的textDirection功能一样，都用于确定alignment对齐的参考系，即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右，即从左往右的顺序；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左，即从右往左的顺序 fit:此参数用于确定没有定位的子组件如何去适应Stack的大小。StackFit.loose表示使用子组件的大小，StackFit.expand表示扩伸到Stack的大小 overflow：此属性决定如何显示超出Stack显示空间的子组件；值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。 children:子组件数组 Positioned const Positioned({ Key key, this.left, this.top, this.right, this.bottom, this.width, this.height, @required Widget child, }) left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定需要定位元素的宽度和高度。注意，Positioned的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位组件，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理. 例子： Stack( fit: StackFit.loose,//保证组件真实大小 children: [ Positioned.fill( child: Container( color: Colors.red, )), Positioned.fill( left: 20, right: 20, bottom: 20, top: 20, child: Container( color: Colors.deepOrangeAccent, )), Positioned.fill( left: 40, right: 40, bottom: 40, top: 40, child: Container( color: Colors.orange, )), ], ) Positioned.fill表示充满父组件，不过还可以指定left、right、top、bottom一个或者多个来约束大小。 第一个边距是0,第二个边距是20，第三个边距是40，大小一次减小。 效果： 例子二： Stack( fit: StackFit.loose, alignment: Alignment.bottomRight, children: [ Positioned( left: 0, right: 0, height: 50, child: Container( color: Colors.red, alignment: Alignment.center, child: Text('Are you OK?'), ), ), Positioned( right: 0, height: 50, width: 50, top: 0, child: Container( color: Colors.red, alignment: Alignment.center, child: Text('I ma Jack!'), ), ), Positioned( height: 40, width: 60, child: Container( color: Colors.blue, alignment: Alignment.center, child: Text('hello'), ), ), ], ) Are you ok?未指定位置，只是指定了大小，上下位置未指定，所以上下位置遵从父组件的alignment,在父组件底部。 I am Jack!指定了具体的上下和大小，则忽略父组件的位置参数。 hello至指定大小，横轴和纵轴都未指定，所以遵从父组件的bottomRight，在父组件的右下角。 效果图： 实例三： Stack( fit: StackFit.expand, alignment: Alignment.center, children: [ Container( child: Text(\"Hello world\", style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( top: 20.0, child: Container( child: Text(\"Are you OK?\"), color: Colors.blue, ), ), Positioned( left: 18.0, child: Container( child: Text(\"I am Jack\"), color: Colors.blue, )), ], ) Hello world，未指定位置，故遵从父组件fit属性，铺满父组件。 因为是层叠布局，第一个指定了位置，所以不会铺满, Are you OK?指定了位置，大小是控件大小，根据文字自动算出，所以展示实际大小。 I am Jack指定位置，大小有子组件字符串自动算出，故未铺满父组件。 效果： "},"books/4.6align.html":{"url":"books/4.6align.html","title":"4.6 对齐与相对定位（Align","keywords":"","body":"4.6 对齐与相对定位(Align) 4.6.1 Align Align组件可以调整子组件的位置，并根据父组件的高度和宽度来确定自身的高度，我们来看下属性： Align({ Key key, this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget child, }) alignment在父组件中的位置，我们看下他的所有值和计算方式。 TopLeft = Alignment(-1.0, -1.0)中间点是[0,0],右下角是[1,1],具体的看下图： alignment 含义 topLeft 顶部左侧 topCenter 顶部中间 topRight 顶部右侧 centerLeft 中间侧 center 中间 centerRight 中间右侧 bottomLeft 底部左侧 bottomCenter 底部中间 bottomRight 底部右侧 widthFactor和heightFactor是父组件/当前组件的比例系数，在父组件未指定具体大小的时候，则通过计算得出父组件大小，具体公式： 子组件宽度* widthFactor =父组件宽度 子组件高度* heightFactor =父组件高度 例子： Container( color: Colors.black12, child: Align( alignment: Alignment.bottomRight, widthFactor: 2, heightFactor: 2, child: FlutterLogo( size: 30, )), ), 效果： 当前logo大小是30*30,父组件大小是30*2=60,宽度和高度一致。当显示指定大小，则忽略该参数。 Container( width: 200, height: 200, color: Colors.black12, child: Align( alignment: Alignment.bottomRight, widthFactor: 2, heightFactor: 2, child: FlutterLogo( size: 30, )), ), 效果： 除了这种方式，也可以在父组件中指定子组件的位置 Container( width: 200, height: 200, color: Colors.black12, alignment: Alignment.center, child: Align( alignment: Alignment.bottomRight, widthFactor: 2, heightFactor: 2, child: FlutterLogo( size: 30, )), ) 当父组件中指定了位置，则在Align中Logo站的大小还是widthFactor * 30,再次基础上面再执行子组件的位置。也就是父组件大小是200*200,子组件Logo具体大小是30*30,Align相对于父组件居中，占地大小是60*60,Logo相对于Align在底部右侧。 千言万语不如一张图： 根据源码得知： static const Alignment topLeft = Alignment(-1.0, -1.0) 其实官方的9中位置，只是提前定义好的，如果自己想要有其他的具体的位置的话，可以使用Alignment(x, y)或者FractionalOffset(x, y)来指定具体的其他位置。 Alignment Alignment其实就是一个坐标，具体的坐标系是 原点在中间，组件的偏移量换算公式是 (Alignment.x*childWidth/2+childWidth/2, Alignment.y*childHeight/2+childHeight/2) childWidth在子组件的宽度，childHeight是子组件的高度 我们再看这个例子： Container( width: 200, height: 200, color: Colors.black12, child: Align( alignment: Alignment(0, 1), child: FlutterLogo( size: 30, )), ) 我们将Alignment(1.0, -1.0)带入上面的工时得出：FlutterLogo实际偏移坐标是(100,200) 再看另外一个例子： Container( width: 200, height: 200, color: Colors.black12, child: Align( alignment: Alignment(2, 1), child: FlutterLogo( size: 30, )), ) 经过计算得出FlutterLogo偏移量是(300,200)。 FractionalOffset FractionalOffset是继承Alignment，他们最大不同就是原点坐标不一致，Alignment原点在组件中间,FractionalOffset在组件左上角，和iOS坐标系有点类似。 坐标系如图所示： 偏移量公式是 实际偏移 = (FractionalOffse.x * childWidth, FractionalOffse.y * childHeight) 下面我们看个例子： Container( width: 200, height: 200, color: Colors.blue[50], child: Align( alignment: FractionalOffset(0.5, 0.5), child: FlutterLogo( size: 30, )), ), 将公式带入FractionalOffset(0.5, 0.5)得出，最终FlutterLogo的偏移量是(100,100). 再看另外一个例子; Container( width: 200, height: 200, color: Colors.blue[50], child: Align( alignment: FractionalOffset(0, -0.1), child: FlutterLogo( size: 30, )), ), 将公式带入FractionalOffset(0, -0.1)得出，最终FlutterLogo的偏移量是(0,-20). 效果如下： 4.6.2 Center Center是继承Align的，源码很简单 class Center extends Align { /// Creates a widget that centers its child. const Center({ Key key, double widthFactor, double heightFactor, Widget child }) : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child); } 因为Align默认是位置是center,所以用Align()和Center效果是一致的。只是Center无法另外指定其他位置。 我们看下面的例子： DecoratedBox( decoration: BoxDecoration(color: Colors.blue), child: Center( child: Text('center2'), ), ), SizedBox( height: 20, ), DecoratedBox( decoration: BoxDecoration(color: Colors.blue), child: Center( widthFactor: 1, heightFactor: 1, child: Text('center2'), ), ) 效果： 当widthFactor和heightFactor没指定时，默认是铺满父容器的 总结 这一节主要讲解了Align组件及两种偏移类Alignment 和FractionalOffset，读者需要理解这两种偏移类的区别及各自的坐标转化公式。另外，在此建议读者在需要制定一些精确的偏移时应优先使用FractionalOffset，因为它的坐标原点和布局系统相同，能更容易算出实际偏移。 "},"books/5.1padding.html":{"url":"books/5.1padding.html","title":"5.1 填充（Padding）","keywords":"","body":"5.1 Padding Padding属于对于组件的约束条件，用起来也很简单。 其实padding也是容器来组件的属性，这个和css盒子模型保持一致，另外一个参数是margin是容器的外边距，padding是内边距。 看下图就理解了： 组件C和A的距离可以用Margin表示，而A内部显示文本B中的Padding则是J2/j3/j4/j5表示4个方向的距离。 我们看下属性： Widget _body() { return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Container( color: Colors.black12, child: Padding( /// 设置上下左右各10像素 颜色是父级颜色 padding: EdgeInsets.all(10), child: Container( color: Colors.red, child: Text('1'), ), ), ), Container( color: Colors.black12, child: Padding( /// 设置上下20像素 颜色是父级颜色 padding: EdgeInsets.symmetric(vertical: 20), child: Container( color: Colors.blue, child: Text('2'), ), ), ), Container( color: Colors.black12, child: Padding( /// 设置上下左右各30像素 颜色是父级颜色 padding: EdgeInsets.only(left: 30, top: 30, right: 30, bottom: 30), child: Container( color: Colors.orange, child: Text('3'), ), ), ) ], ), ); } "},"books/5.2constrainedBox.html":{"url":"books/5.2constrainedBox.html","title":"5.2 尺寸限制类容器（ConstrainedBox等）","keywords":"","body":"5.2 尺寸限制的容器 Flutter提供了很多个尺寸限制的容器比如：ConstrainedBox、SizedBox、UnconstrainedBox、AspectRatio等. 5.2.1 ConstrainedBox ConstrainedBox用于最子组件添加额外的约束，例如：如果你想子组件的最小高度是100像素，可以使用const BoxConstraints(minHeight: 100.0)作为子组件的约束。 例子 我们在第一个Container限制最小高度是50px,最小宽度50px，最大宽度和高度200px，第二个是大小为50px的Container用来做对比。 当子控件小于父控件的尺寸限制的时候，遵从父控件的约束。 Column( children: [ Container( constraints: BoxConstraints( minWidth: 50, minHeight: 50, maxHeight: 200, maxWidth: 100), color: Colors.red, child: Container( width: 30, height: 30, color: Colors.blue, ), ), Container( height: 50, width: 50, color: Colors.red, ) ], ) 效果： const BoxConstraints({ this.minWidth = 0.0, this.maxWidth = double.infinity, this.minHeight = 0.0, this.maxHeight = double.infinity, }) 当不设置最大宽度和高度，默认是设置尽可能的大，最下都是0.0。BoxConstraints还有很多便捷函数; BoxConstraints.tight(Size size)固定size BoxConstraints.tightFor({ double width, double height, })最小宽度和高度，最大还是默认尽可能大。 BoxConstraints.tightForFinite({ double width = double.infinity, double height = double.infinity, })设置width和height就是设置里最下，最大仍然是尽可能大double.infinity. BoxConstraints.loose(Size size)真实大小 BoxConstraints.expand弹性到最大 5.2.2 SizedBox SizedBox用于给子元素指定固定高度，如： SizedBox( width: 80.0, height: 80.0, child: redBox ) 等价于： Container( constraints: BoxConstraints(maxWidth: 100, maxHeight: 100), color: Colors.red, ) SizedBox中的createRenderObject()是返回的是RenderConstrainedBox @override RenderConstrainedBox createRenderObject(BuildContext context) { return RenderConstrainedBox( additionalConstraints: _additionalConstraints, ); } 5.2.3 复杂情况 限制重复 如果一个组件有多个父级ConstrinedBox限制，那么最后谁会生效呢？ 一级组件限制大小是100，二级限制是50，那么最最终显示的是100. ConstrainedBox( constraints: BoxConstraints( maxWidth: 100, maxHeight: 100, ), child: ConstrainedBox( constraints: BoxConstraints( maxWidth: 50, maxHeight: 50, ), child: _redBox(), ), ) 效果如下： 当maxHeight多重限制则显示较小的 那么minWidth?有兴趣的同学可以自己试一下。 当子层级不想使用父级约束了怎么办？Flutter提供了UnconstrainedBox用来去除父级的限制。 UnconstrainedBox UnconstrainedBox只会把父级的约束失效，不会对子部件产生其他影响。我们做一个测试，父类最小是100X100,去除影响后子部件应该是50X50. Widget _widget() { return Container( color: Colors.black12, constraints: BoxConstraints( minHeight: 100, minWidth: 100, maxWidth: 200, maxHeight: 200), child: UnconstrainedBox( child: _redBox(), ), ); } 我们看下效果： 之类父级的背景还是100X100，子部件大小是50X50,虽然没有影响子部件，但是父级的约束对父级影响还是在的。 当我们开发中发现，虽然指定了BoxConstraints的大小，但是还是失效了，显而易见是父级已经指定了约束，那么我们就是用UnconstrainedBox来包裹一下，即可去掉父级对子级的影响。 "},"books/5.7clip.html":{"url":"books/5.7clip.html","title":"5.7 剪裁（Clip）","keywords":"","body":"5.7 裁剪Clip Flutter中提供了一些裁剪函数，可以用于部件进行裁剪操作。 裁剪 效果 ClipOval 将子部件剪切为内贴圆型，当为矩形时，内切圆为椭圆 ClipRRect 剪切为圆角矩形 ClipRect 剪切子部件到实际占用的举行大小(溢出部分剪切掉) 例子： ClipOval( child: Container( width: 100, height: 100, color: Colors.blue, ), ) 效果： Widget _body() { Widget avator = Container( width: 100, height: 100, color: Colors.blue, ); return Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text('ClipOval 剪切圆形'), ClipOval( child: avator, ), Text('ClipOval 圆角'), ClipRRect( borderRadius: BorderRadius.all(Radius.circular(10)), child: avator, ), Text('ClipOval 剪切为原来的1/4'), ClipRect( child: Align( alignment: Alignment.topRight, widthFactor: 0.5, heightFactor: 0.5, child: avator, ), ) ], ); } } 效果： 5.7.2 CustomClipper CustomClipper是剪切自定义的特殊形状的部件，是抽象类，需要自己去实现。我们来实现一个画出笑脸的例子。 BaseCustomPath是实现了剪切的路径。 class BaseCustomPath extends CustomClipper { @override Path getClip(Size size) { Path path = Path(); path.moveTo(size.width / 2, 40); path.lineTo(size.width - 15, size.height - 15); path.lineTo(15, size.height - 15); double p1 = 1 * pi; path.addArc(Rect.fromLTWH(30,30,30,30), p1, p1 + 2 * pi); path.lineTo(15, size.height - 15); path.addArc( Rect.fromLTWH(size.width - 30,30,30,30), p1, p1 + 2 * pi); path.lineTo(0, 0); return path; } @override bool shouldReclip(CustomClipper oldClipper) { return this != oldClipper; } } 布局代码： ClipPath( child: avator, clipper: BaseCustomPath(), ) 效果： 蓝色看着不是很好看，我们换一个图片。 原图是： 效果图： 跟多好玩的剪切路径自己去探索哦。 "}}