{"./":{"url":"./","title":"简介","keywords":"","body":"Introduction "},"books/3.2state.html":{"url":"books/3.2state.html","title":"3.2：状态管理","keywords":"","body":"状态管理 3.2.1 状态管理 简介 Widget分为有状态和无状态，有状态的则就需要有人来管理了，父组件管理和自己管理各有什么优劣呢？ 如果状态是用户数据，如：复选框、滑块位置、最好有父组件管理。 如果状态是有关界面的效果，例如颜色、动画、最好由自己管理。 如果某一个状态是不同的Widget共享，则最好是父组件管理。 在组件内部管理，封装性当然是好一点，而缺少了灵活性，在父组件中管理子组件的状态，则更灵活，设计组件的时候，应已灵活多变为要点，多位父组件管理。 接下来我们用几个例子分别演示自己管理、父管理、多组件管理来说明状态管理不同方式。 我们使用一个简单的例子：一个盒子，活跃状态是红色，不活跃是灰色. 自己管理状态 自己管理状态，外接无序参与即可完成左右步骤。完全封闭。 class TapBox extends StatefulWidget { TapBoxState createState() => TapBoxState(); } class TapBoxState extends State { bool _selected = false; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('自己管理状态'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Container( color: _selected ? Colors.red : Colors.black12, child: FlatButton( child: Text(_selected ? 'Active' : 'Inactive'), onPressed: _tap, ), ) ], ), ), ); } void _tap() { setState(() { _selected = !_selected; }); } } 效果: 父组件管理 父组件可以指定子组件的状态，当条件复杂的时候，提交数据到服务后台，失败了，这种情况就用父组件来传递状态到子组件。 /// 封装好的子组件 class TapBox2 extends StatefulWidget { final bool selected; final onChange onchange; TapBox2({Key key, this.selected, this.onchange}) : super(key: key); TapBoxState2 createState() => TapBoxState2(); } typedef onChange = Function(bool); class TapBoxState2 extends State { bool _selected; @override void initState() { _selected = widget.selected == true; super.initState(); } @override Widget build(BuildContext context) { return Container( color: widget.selected == true ? Colors.red : Colors.black12, child: FlatButton( child: Text(widget.selected == true ? 'Active' : 'Inactive'), onPressed: _tap, ), ); } void _tap() { if (widget.onchange != null) { _selected = !_selected; widget.onchange(_selected); } } } /// 父组件来管理 class TapBox extends StatefulWidget { TapBoxState createState() => TapBoxState(); } class TapBoxState extends State { bool _selected = false; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('管理状态'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Container( color: _selected ? Colors.red : Colors.black12, child: TapBox2( onchange: (v) { setState(() { _selected = v; }); }, selected: _selected, ), ) ], ), ), ); } } 效果： 混合管理 有些组件，混合方式比较适用，这种情况，组件自身管理一部分状态，父组件管理一些外部状态。 下面的例子是不活跃状态按下盒子周围显示红色边框，活跃状态按下显示蓝色边框，抬起时边框消失，点击完成后，状态进行改变。活跃状态由外部管理,边框变化有内部管理。 class TapBox3 extends StatefulWidget { final bool selected; final onChange onchange; TapBox3({Key key, this.selected, this.onchange}) : super(key: key); TapBoxState3 createState() => TapBoxState3(); } class TapBoxState3 extends State { bool _touching = false; @override void initState() { super.initState(); } @override Widget build(BuildContext context) { return Container( child: GestureDetector( child: Container( height: 50, width: 120, alignment: Alignment.center, child: Text(widget.selected == true ? 'Active' : 'Inactive'), decoration: new BoxDecoration( color: widget.selected == true ? Colors.red : Colors.black12, border: _touching ? Border.all( color: widget.selected == false ? Colors.red : Colors.blue, width: 4) : null), ), onTap: _tap, onTapDown: (TapDownDetails details) { _touchStart(); }, onTapUp: (detail) { _touchend(); }, ), ); } void _tap() { if (widget.onchange != null) { widget.onchange(!widget.selected); } } void _touchStart() { setState(() { _touching = true; }); } void _touchend() { setState(() { _touching = false; }); } } /// 父组件管理活跃状态 Container( color: _selected ? Colors.red : Colors.black12, child: TapBox3( onchange: (v) { setState(() { _selected = v; }); }, selected: _selected, ), ) 效果： 3.2.2 全局状态管理 当跨页面状态管理的时候，上面的情况已经不适用，我们可以采用eventBus来进行数据传递，或者使用Provider进行数据管理和页面刷新。 自己管理或者父级管理本质是可以调用State的setState((){})进行Widget的build函数，当这些组件不在一个页面，则无法进行直接通信，这时我们有2中方法解决。 实现一个全局的时间总线，将状态对应一个事件，然后在对应的Widget进行刷新。 使用专门管理状态的包，如Provider、Redux，详细用法见pub 在后续章节中会介绍状态管理的机制原理，再次不做累述。 "},"books/3.3textandstyle.html":{"url":"books/3.3textandstyle.html","title":"3.3：文本和样式","keywords":"","body":"文本和样式 3.1 Text and TextStyle text用于显示简单的文字和样式，下面看下简单的例子 Text('text HelloWord', textAlign: TextAlign.left,) Text( '加了style的文本', style: TextStyle( color: Colors.red, fontSize: 30, height: 1.4, background: new Paint()..color = Colors.black12, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy), ) 效果如下： 一个是简单的文本显示，属性 textAlign:TextAlign.left 好像没起作用，原因是文本没超过一行，没效果。 底部波纹代码如下： decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.wavy 这三行的样式是在底部添加了波纹线，SDK一共给了4中线的样式， enum TextDecorationStyle { /// Draw a solid line solid, /// Draw two lines double, /// Draw a dotted line dotted, /// Draw a dashed line dashed, /// Draw a sinusoidal line wavy } 效果如下： 喜欢哪一个随意挑选哦。 当文本超过一行的话可以截断或者换行 用到了属性TextOverflow Text( 'TextOverflow.visible' * 10, textAlign: TextAlign.left, maxLines: 1, overflow: TextOverflow.visible, ) 官方提供了四种方式，在设置maxLines=2效果如下 默认maxLines是无限的，自动换行的。如果设置固定行数，则文本最多不超过该行数，超过该行数则被截断，截断方式如上图所示。系统还提供了文字间隔wordSpacing和字符间隔letterSpacing，字体放大倍数textScaleFactor,如果不设置 ，会 MediaQueryData.textScaleFactor获取，默认是1.0。 3.2. TextSpan 首先看一个简单例子： TextSpan( text: 'Jok Ma,hello!', style: TextStyle( fontSize: 20, ), children: [ TextSpan( text: 'Bo', style: TextStyle( fontSize: 20, color: Colors.blue, backgroundColor: Colors.black12)), TextSpan( text: 'b,hello!', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent)), TextSpan( text: 'two line', style: TextStyle( fontSize: 30, color: Colors.red, backgroundColor: Colors.lightGreenAccent, decoration: TextDecoration.underline, decorationColor: Colors.blue, decorationStyle: TextDecorationStyle.double)), TextSpan( text: '\\n点击打开我 🖱http://www.fgyong.cn', style: TextStyle(fontSize: 20, height: 2), recognizer: new TapGestureRecognizer()..onTap = () { _openUrl('http://www.fgyong.cn'); }, ), ]), ), //是否打开url void _openUrl(String url) async { if (await canLaunch(url)) { await launch(url); } else { throw 'could not launch $url'; } } 效果如下： 这里使用了TextSpan组件，和Text类似的都有style，这一点完全一致，不同的是TextSpan可以添加children,这是一个数组，可以连续添加很多TextSpan,每个都可以单独设置样式，比如一个手机号，一个网址，。。可以通过recognizer: new TapGestureRecognizer()..onTap = _openUrl来实现点击文本跳转_openUrl函数，这给文本带来了更多的可能性。 height属性是计算方式是fontSize * height，默认是1.0，设置字体大小还有一个属性是textScaleFactor，这个是计算方式是fontSize * textScaleFactor,默认是1.0. fontSize字体具体的大小 height 行高 textScaleFactor，本质是fontSize * textScaleFactor,默认是1.0 * fontSize 3.3 DefaultTextStyle 可以被继承的TextStyle,当一个子树基本样式类似，可以使用DefaultTextStyle DefaultTextStyle( //1.设置文本默认样式 style: TextStyle( color: Colors.blue, fontSize: 30.0, ), textAlign: TextAlign.start, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(\"Jack Ma\"), Text(\"I am Ok\"), Text( \"I am Jack\", style: TextStyle( inherit: false, //2.不继承默认样式 color: Colors.grey), ), ], ), ) 效果如下： 这里边默认样式是字体大小30(逻辑像素),然后通过DefaultTextStyle设置子树的样式，这样子所有子树中的样式都遵从该样式，可以通过inherit: false显示指定不继承该样式。 3.3.4 字体 当开发人员想使用自定义(非默认)字体,可以去Google下载，则可以通过pubspec.yml中声明他，然后将字体移动到目录下fonts下： 然后在pubspec.yml的声明如下： fonts: - family: Merriweather fonts: - asset: fonts/Merriweather-Black.ttf - asset: fonts/Merriweather-Light.ttf weight: 700 这样子就可以在textStyle中使用了 TextStyle(fontFamily: 'Merriweather',) 或者在主题中直接声明默认的字体 ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, fontFamily: 'Merriweather') 更多字体设置见官网 如果想省事可以使用google_fonts. "},"books/3.4button.html":{"url":"books/3.4button.html","title":"3.4：按钮","keywords":"","body":"3.4 按钮 3.4.1 Material组件库的按钮 Material 组件库中提供了多种按钮组件如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton组件的包装定制，所以他们大多数属性都和RawMaterialButton一样。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现波纹的动画）。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 FlatButton FlatButton是一个扁平按钮，在默认背景透明无阴影，按下后有深色背景，如图： 使用起来很简单： FlatButton( child: Text('nomal'), onPressed: () {},), RaisedButton RaisedButton是漂浮按钮，默认带有背景和阴影，活跃状态按钮背景变大，如图所示 IconButton IconButton默认是icon作为widget，背景透明，按压状态下，波纹状，背景变大。如图所示 FloatingActionButton FloatingActionButton即是悬浮按钮，默认背景是主题色，按压也会有波纹。右边是按压，左边是正常状态。 使用例子： FloatingActionButton(child: Icon(Icons.add), onPressed: () {}, ) BackButton CloseButton 官方封装好的返回和关闭按钮,如图： 使用例子: BackButton(onPressed: () {},), CloseButton(onPressed: () {},), OutlineButton OutlineButton带边框的按钮，默认有灰色边框，按压下边框高亮，可以同时兼备icon和label,如图： 使用也很简单： OutlineButton( child: Text('OutlineButton'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('label'), onPressed: () {}, ), SizedBox( width: 10, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text('active'), onPressed: () {}, ) 自定义按钮外观 外观可以通过属性来定义，不同按钮基本一样，我们以IconButton为例子，介绍一下常用属性，详细的可以查看官方文档。 textColor : 文本和icon的颜色 disabledBorderColor: 不点击状态下的边框颜色 highlightedBorderColor： 点击状态下边框颜色 splashColor:波纹颜色 borderSide：边框宽度和颜色 示例： 代码如下： OutlineButton.icon( onPressed: () {}, icon: Icon(Icons.add), label: Text('diy style'), color: Colors.black12, textColor: Colors.blue, disabledBorderColor: Colors.black, highlightedBorderColor: Colors.greenAccent, splashColor: Colors.red ) 如何自己实现一个Button,在后续章节中会再次详细讲到，在此不过多累述。 "},"books/3.5img.html":{"url":"books/3.5img.html","title":"3.5：图片和Icon","keywords":"","body":"3.5 图片及Icon 3.5.1 图片 Flutter中，我们可以通过image加载并显示图片，数据源可以是asset、file、内存、网络。 Image imageWidget有一个必选的参数，对应了一个ImageProvider,下边我们来演示一下image的使用。 从assets加载 首先将文件复制到工程指定文件夹内，我们移动至img文件夹下， 然后在pubpspec.yaml内声明 assets: - img/1.jpeg 然后运行flutter pub get,(或者 android studio 中编辑 pubpspec.yaml点击右上角pub get按钮)。 然后代码中可以使用了，实例: Image.asset('img/1.jpeg') 效果如图所示： 从网络加载 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, ) 或者使用快捷的构造函数Image.network用于从网络加载、显示图片 Image.network( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\", width: 120, ), 参数 Image在显示图片是定义了一系列参数，通过定义一系列参数达到改变图片外观、大小、混合效果等，我们看下Image的主要参数： const Image({ ... this.width, //图片的宽 this.height, //图片高度 this.color, //图片的混合色值 this.colorBlendMode, //混合模式 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ... }) width、height ：用户设置图片大小，当不指定大小，图片则在富容器内进行占满，当设置width或height时，另外一个会按照比例缩放，但可以通过fit来指定缩放规则。 fit:指定图片在容器内的缩放规则。有如下几个值 fill:会拉伸铺满，图片会变形 cover: 按照图片的长宽放大后填满容器，不会变形。 fitWidth: 图片会随着缩放到显示的宽度，在保证不变形的条件下进行适应宽度,超出部分会裁剪。 fitHeight:图片高度会按照等比例缩放到适应高度，超出部分会裁剪。 none: 无适应规则，会显示当前容器的大小，如果图片过大，则只会显示中间部分。 看图，简单明了： color指定混合颜色，colorBlendMode指定混合模式。 例子： Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, ) 效果： repeat是当图片不够容器大小可以设置沿着X或者Y进行重复铺。 Image( image: NetworkImage( \"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593336370404&di=c03084a66d06c1af8995088158e907c3&imgtype=0&src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F13.jpg\"), width: 100.0, height: 200, color: Colors.greenAccent, colorBlendMode: BlendMode.colorBurn, repeat: ImageRepeat.repeat, ) 效果： Image 从网络下载动画 Image从网络下载会与短暂的 空白时间，这是我们不想看到的，我们可以在加载的时候显示菊花转。 Image( image: NetworkImage( \"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2053400745,529716701&fm=26&gp=0.jpg\"), width: 100.0, height: 200, loadingBuilder: ( BuildContext context, Widget child, ImageChunkEvent loadingProgress, ) { if (loadingProgress == null) { return child; } return CircularProgressIndicator(); }, ) 效果如图所示： 3.5.2 Icon flutter中可以使用iconFont，就是将图标做成文件，通过指定字符加载不同icon. 字体文件中，每一个字符都对应一个位码，不同字体就是字形不同，即字符对应的字形不同，最终渲染的不同的图标。 Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下 uses-material-design: true Material Design所有图标可以在其官网查看. 例子： Text('\\uE915 \\uE002 \\uE900', style: TextStyle( fontFamily: \"MaterialIcons\", fontSize: 24.0, color: Colors.green)) 效果： 对着code 找图标明显不是太人性化，那么可以使用cupertino_icons Icon( Icons.clear, color: Colors.red, ), Icon( Icons.add, color: Colors.greenAccent, ), Icon( Icons.collections, color: Colors.blue, ), Icon( Icons.extension, color: Colors.orange, ) 使用自定义字体图标 我们也可以使用自定义字体图标。iconfont.cn上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在Flutter中，我们使用ttf格式即可。 假设我们项目中需要使用一个书籍图标和微信图标，我们打包下载后导入： 导入字体图标文件；这一步和导入字体文件相同，假设我们的字体图标文件保存在项目根目录下，路径为\"fonts/iconfont.ttf\"： fonts: - family: myIcon #指定一个字体名 fonts: - asset: fonts/iconfont.ttf 为了使用方便，我们定义一个MyIcons类，功能和Icons类一样：将字体文件中的所有图标都定义成静态变量： class MyIcons{ // book 图标 static const IconData book = const IconData( 0xe614, fontFamily: 'myIcon', matchTextDirection: true ); // 微信图标 static const IconData wechat = const IconData( 0xec7d, fontFamily: 'myIcon', matchTextDirection: true ); } 使用 Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(MyIcons.book,color: Colors.purple,), Icon(MyIcons.wechat,color: Colors.green,), ], ) 运行后效果如图3-22所示： "},"books/3.6sw.html":{"url":"books/3.6sw.html","title":"3.6：单选和复选矿","keywords":"","body":"3.6 单选和复选 3.6.1 单选和复选 单选和复选很简单，只需要一个value和一个属性来维护每个选择框的value即可。 class BaseSwitch extends StatefulWidget { @override State createState() { return BaseSwitchState(); } } class BaseSwitchState extends State { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('弹框'), ), body: Container( margin: EdgeInsets.all(30), child: _body(), ), ); } bool _state1 = false, _state2 = true, _s3 = true, _s4 = false; Widget _body() { Widget w = Column( children: [ Container( height: 30, child: Text('CupertinoSwitchState:$_state1'), ), CupertinoSwitch( value: _state1, onChanged: (v) { setState(() { _state1 = v; }); }, ), Container( height: 30, child: Text('SwitchStates:$_state2'), ), Switch( value: _state2, onChanged: (v) { setState(() { _state2 = v; }); }, ), Container( height: 30, child: Text('Checkbox'), ), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Checkbox( value: _s3, onChanged: (v) { setState(() { _s3 = v; }); }, ), Checkbox( value: _s4, onChanged: (v) { setState(() { _s4 = v; }); }, ) ], ) ], ); return w; } } 效果如下： 属性和外观 Switch和CheckBox属性很简单，可以设置value来控制是否被选中，需要父级控件来维护,状态改变时也是父级来维护,另外还可以设置activeColor激活颜色，和normal状态的颜色trackColor。 这样子设计组件的好处是，交互交给外部，自己只处理样式，这样子传递的信息可以更灵活。 "},"books/3.7textfield.html":{"url":"books/3.7textfield.html","title":"3.7：输入框","keywords":"","body":"3.7 输入框和表单 输入框有TextField、带有iOS风格的CupertinoTextField,还有表单form. 3.7.1 TextField TextField默认带有下划线，无边框的，属性InputDecoration可以设置默认文字，当编辑状态，文字已动画形式上浮至左上角，这是其他输入框所没有的。其他的看下属性： const TextField({ ... this.controller, this.focusNode, this.decoration = const InputDecoration(), TextInputType keyboardType, this.textInputAction, this.style, this.textAlign = TextAlign.start, this.textAlignVertical, this.textDirection, this.showCursor, this.autofocus = false, this.obscureText = false, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorRadius, this.cursorColor, ... }) controller可以获取文字和设置文字， focusNode 获取焦点 keyboardType键盘类型 textInputAction输入键盘右下角的键 onChanged 当textField的value变化回调函数 onSubmitted提交按键 obscureText true则显示原点，否则显示原文字 cursorWidth光标宽度 cursorRadius 光标圆圈半径 cursorColor光标颜色 textInputAction有多个值，具体见下表格： textInputAction 备注 none Android是IME_ACTION_NONE,iOS没有 unspecified Android's IME_ACTION_UNSPECIFIED,iOS 是return done Android's IME_ACTION_DONE iOS是done go android and iOS 都是go search android and ios is Search send android and ios is send next android and ios is next previous iOS没有，Android's IME_ACTION_PREVIOUS continueAction Android没有，iOS上是contion join android and ios is join route android没有，ios is route emergencyCall android没有，ios is Emergency Call newline android and ios都没有，只是方便开发人员调试 例子： _focusNode = new FocusNode(); _editingController = new TextEditingController(); _field = TextField( focusNode: _focusNode, onChanged: (v) { setState(() {}); }, onSubmitted: (v) { _focusNode.unfocus(); }, controller: _editingController, obscureText: false, //是否是密码 decoration: InputDecoration(hintText: '手机号', labelText: '手机号'), keyboardType: TextInputType.number, ); Column( children: [ Text('TextField'), _field, Text(_editingController.value.text), ], ) 效果如下： iOS-style的组件CupertinoTextField,属性和TextField基本一致; 例子： _editingController2 = new TextEditingController(); _focusNode2 = new FocusNode(); _cupertinoTextField = CupertinoTextField( focusNode: _focusNode2, controller: _editingController2, placeholder: '密码', prefix: Icon(Icons.lock), textInputAction: TextInputAction.go, obscureText: true, ); Column( children: [ SizedBox( height: 30, ), Text('CupertinoTextField'), _cupertinoTextField, ], ) 效果： 监听文本变化 _editingController = new TextEditingController() ..addListener(() { print(\"${_editingController.value.text}\"); }); 或者 TextField( focusNode: _focusNode, onChanged: (v) { print('onChange$v'); }, controller: _editingController, ... ); 收键盘 TextField( focusNode: _focusNode, ); /// 收键盘 _focusNode.unfocus(); 收键盘之前必须在初始化的时候赋值给TextField,另外官方还提供了编辑下一个textField,当下边没有可以提供编辑的textField则进行书键盘操作，有的话则跳至下一个textField. _focusNode.focusInDirection(TraversalDirection.down); 3.7.2 Form Form更新数据和获取数据需要使用_globalKey获取当前的State。 例子： Form( key: _globalKey, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ TextFormField( decoration: const InputDecoration( hintText: 'Enter your email', ), validator: (value) { if (value.isEmpty) { return 'Please enter some text'; } return null; }, ), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: RaisedButton( onPressed: () { // Validate will return true if the form is valid, or false if // the form is invalid. if (_globalKey.currentState.validate()) { // Process data. } }, child: Text('Submit'), ), ), ], ), ) Form子树中可以是多个TextFormField,每个可以单个校验，所有的都校验过了，FormState才是校验通过的，多用于多输入校验。那么我们写一个登陆的简单校验。 例子： _form = Form( key: _globalKey, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ TextFormField( decoration: const InputDecoration( hintText: 'Enter your email', icon: Icon(Icons.mail)), validator: (value) { if (value.isEmpty) { return 'Please enter some text'; } return null; }, ), TextFormField( controller: _editingController3, decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", icon: Icon(Icons.lock)), obscureText: true, //校验密码 validator: (v) { return v.trim().length > 5 ? null : \"密码不能少于6位\"; }), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: RaisedButton( onPressed: () { // Validate will return true if the form is valid, or false if // the form is invalid. if (_globalKey.currentState.validate()) { // Process data. print('校验通过'); } setState(() { _done = _globalKey.currentState.validate(); }); }, child: Text('Submit'), ), ), ], ), ); "},"books/3.8indicator.html":{"url":"books/3.8indicator.html","title":"3.8: 进度指示器","keywords":"","body":"3.8 进度指示器 Material组件库中提供了两种进度指示器：LinearProgressIndicator和CircularProgressIndicator，它们都可以同时用于精确的进度指示和模糊的进度指示。精确进度通常用于任务进度可以计算和预估的情况，比如文件下载；而模糊进度则用户任务进度无法准确获得的情况，如下拉刷新，数据提交等。 3.8.1 LinearProgressIndicator LinearProgressIndicator线形的进度指示器，看文档如下： const LinearProgressIndicator({ Key key, double value, Color backgroundColor, Animation , String semanticsLabel, String semanticsValue, }) value默认为null，效果为动画,范围是[0,1] backgroundColor是动画背景颜色，为静态的 valueColor是动画前景色，可以使用AnimationController搭配达到颜色变化的目的。也可以使用AlwaysStoppedAnimation来达到静态颜色。 例子： LinearProgressIndicator( valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.black12, ) 效果： 设置大小和线条宽度： SizedBox( height: 20, width: 200, child: LinearProgressIndicator( // value: 0.1, valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.black12, ), ), 效果： CircularProgressIndicator CircularProgressIndicator是原型进度指示器，可以自己配置颜色和进度，相关属性紧紧比LinearProgressIndicator多了一个线条宽度strokeWidth. 相关属性： CircularProgressIndicator({ ... double value, Color backgroundColor, Animation valueColor, this.strokeWidth = 4.0 ... }) value默认为null，效果为动画,范围是[0,1] backgroundColor是动画背景颜色，为静态的 valueColor是动画前景色，可以使用AnimationController搭配达到颜色变化的目的。也可以使用AlwaysStoppedAnimation来达到静态颜色。 this.strokeWidth默认为4，可以自定单独设置。 例子： CircularProgressIndicator( valueColor: AlwaysStoppedAnimation(Colors.orange), backgroundColor: Colors.greenAccent, ) 效果： 自定义外观 通过strokeWidth定义线条宽度，通过valueColor定义渐变色,backgroundColor定义背景色。 例子： AnimationController _controller; @override void initState() { _controller = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)) ..repeat(); super.initState(); } SizedBox( height: 200, width: 200, child: CircularProgressIndicator( valueColor: ColorTween(begin: Colors.grey, end: Colors.orange) .animate(_controller), backgroundColor: Colors.black12, strokeWidth: 10, ), ), 效果： 更多进度指示器 和好网的样式可以参考flutter_easyHub 进度条 利用value可以定制，可以用在下载进度指示器上。 例子： AnimationController _controller; Timer _timer; double _value = 0; @override void initState() { _controller = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)) ..repeat(); _timer = Timer.periodic(Duration(milliseconds: 16), (t) { _value += 0.01; if (_value >= 1.0) { _value = 0; } setState(() {}); }); super.initState(); } SizedBox( height: 200, width: 200, child: Stack( children: [ Positioned.fill( child: CircularProgressIndicator( valueColor: ColorTween(begin: Colors.blue, end: Colors.orange) .animate(_controller), backgroundColor: Colors.black12, strokeWidth: 10, value: _value, ), ), Positioned.fill( child: Center( child: Text( '${(_value * 100).toDouble().toStringAsFixed(2)}%', style: TextStyle(fontSize: 20, color: Colors.orange), ), )) ], ), ), 效果： "},"books/3.9dialog.html":{"url":"books/3.9dialog.html","title":"3.9: 弹窗","keywords":"","body":"3.9 弹窗 组件库中提供了多种弹窗适用于选择时间、定时、用户选择、表单提交等。。。 3.9.1 showCupertinoDialog showCupertinoModalPopup是一个iOS-style风格的弹窗，从底部弹出，附带了一个唯一动画和渐变消失的动画，按钮也是iOS-style风格，点击遮罩返回。下面看下代码： 例子： void _showActionSheet() { showCupertinoModalPopup( context: context, builder: (ctx) { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是支付选项，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); }); } 效果： 3.9.2 showCupertinoDialog showCupertinoDialog是对showGeneralDialog的一个封装，只是barrierDismissible、barrierColor、transitionDuration进行了iOS-style格调的设置。 源码： Future showCupertinoDialog({ @required BuildContext context, @required WidgetBuilder builder, bool useRootNavigator = true, RouteSettings routeSettings, }) { assert(builder != null); assert(useRootNavigator != null); return showGeneralDialog( context: context, barrierDismissible: false, barrierColor: CupertinoDynamicColor.resolve(_kModalBarrierColor, context), // This transition duration was eyeballed comparing with iOS transitionDuration: const Duration(milliseconds: 250), pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return builder(context); }, transitionBuilder: _buildCupertinoDialogTransitions, useRootNavigator: useRootNavigator, routeSettings: routeSettings, ); } 和showCupertinoModalPopup区别是一个从底部，一个全屏。 下面看下例子； showCupertinoDialog( context: context, builder: (ctx) { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是showCupertinoDialog'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); }); 效果： 3.9.3 showAboutDialog showAboutDialog是flutter官方封装的一个关于我的组件，包含了版本号、icon、以及Licenses内容。 例子： showAboutDialog( context: context, applicationVersion: '1.0.0', applicationIcon: Icon(Icons.scatter_plot), applicationName: 'Jack ma', ); 3.9.4 showGeneralDialog showGeneralDialog是一个比较基础的弹窗， 可以用这个封装成任意其他的弹窗。 例子： showGeneralDialog( context: context, barrierDismissible: true, barrierLabel: 'cancel', transitionDuration: Duration(milliseconds: 1000), pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return Material( child: Scaffold( body: Center( child: CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是showGeneralDialog，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction( onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction( onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ), ), ), ); }); 效果： 3.9.4 showDialog showDialog也是封装的showGeneralDialog,只是固定参数进行了适配。 void _showDialog() { showDialog(context: context, child: bd()); } Widget bd() { return CupertinoActionSheet( title: Text('温馨提示'), message: Text('我是支付选项，任意选择一个进行支付哦'), actions: [ CupertinoActionSheetAction(onPressed: _pop, child: Text('微信')), CupertinoActionSheetAction(onPressed: _pop, child: Text('支付宝')), CupertinoActionSheetAction( onPressed: _pop, child: Text('取消'), isDestructiveAction: true, ), ], ); } 3.9.6 showDatePicker showDatePicker是官方提供的一个日历组件，也是座位弹窗形式展现，参数很简单。 showDatePicker({ @required BuildContext context, @required DateTime initialDate, @required DateTime firstDate, @required DateTime lastDate ... } 只需要配置当前的上下文和开始结束时间即可。 例子： showDatePicker( context: this.context, initialDate: DateTime.now(), //初始时间 firstDate: DateTime.now(), //开始时间 lastDate: DateTime.now().add(Duration(days: 10)), //最后时间是当前时间加上10天 initialDatePickerMode: DatePickerMode.year, //最开始展示年份 initialEntryMode: DatePickerEntryMode.input, //开始是输入时间还是日历 selectableDayPredicate: (time) { print(time.toString()); return true; }) 效果： 3.9.7 showTimePicker showTimePicker是一个选择时间长短的控件,使用起来很简单，只需要传入默认时间即可。 showTimePicker( context: this.context, initialTime: TimeOfDay(hour: 1, minute: 10)) 效果： "}}